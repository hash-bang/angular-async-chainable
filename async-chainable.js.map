{"version":3,"names":[],"mappings":"","sources":["async-chainable.js"],"sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.asyncChainable = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nangular.module('angular-async-chainable', [])\n.service('$async', function() {\n\tif (!window.asyncChainable) return console.error('asyncChainable not loaded!');\n\treturn window.asyncChainable;\n});\n\n},{}],2:[function(require,module,exports){\nvar async = require('async');\n\n/**\n* Examines an argument stack and returns all passed arguments as a CSV\n* e.g.\n*\tfunction test () { getOverload(arguments) };\n*\ttest('hello', 'world') // 'string,string'\n*\ttest(function() {}, 1) // 'function,number'\n*\ttest('hello', 123, {foo: 'bar'}, ['baz'], [{quz: 'quzValue'}, {quuz: 'quuzValue'}]) // 'string,number,object,array,collection'\n*\n* @param object args The special JavaScript 'arguments' object\n* @return string CSV of all passed arguments\n*/\nfunction getOverload(args) {\n\tvar i = 0;\n\tvar out = [];\n\twhile(1) {\n\t\tvar argType = typeof args[i];\n\t\tif (argType == 'undefined') break;\n\t\tif (argType == 'object' && Object.prototype.toString.call(args[i]) == '[object Array]') { // Special case for arrays being classed as objects\n\t\t\targType = 'array';\n\t\t\tif (args[i].length && args[i].every(function(item) {\n\t\t\t\treturn (typeof item == 'object' && Object.prototype.toString.call(item) == '[object Object]');\n\t\t\t}))\n\t\t\t\targType = 'collection';\n\t\t}\n\t\tout.push(argType);\n\t\ti++;\n\t}\n\treturn out.toString();\n};\n\n// Utility functions {{{\n/**\n* Return true if a variable is an array\n* @param mixed thing The varable to examine\n* @return bool True if the item is a classic JS array and not an object\n*/\nfunction isArray(thing) {\n\treturn (\n\t\ttypeof thing == 'object' &&\n\t\tObject.prototype.toString.call(thing) == '[object Array]'\n\t);\n}\n\n\n/**\n* Return true if a variable is an object\n* @param mixed thing The varable to examine\n* @return bool True if the item is a classic JS array and not an object\n*/\nfunction isObject(thing) {\n\treturn (\n\t\ttypeof thing == 'object' &&\n\t\tObject.prototype.toString.call(thing) != '[object Array]'\n\t);\n}\n// }}}\n\n// Plugin functionality - via `use()`\nvar _plugins = {};\nfunction use(module) {\n\tmodule.call(this);\n\treturn this;\n};\n// }}}\n\n/**\n* Queue up a function(s) to execute in series\n* @param array,object,function The function(s) to execute\n* @return object This chainable object\n*/\nfunction series() {\n\tvar calledAs = getOverload(arguments);\n\tswitch(calledAs) {\n\t\tcase '':\n\t\t\t// Pass\n\t\t\tbreak;\n\t\tcase 'function': // Form: series(func)\n\t\t\tthis._struct.push({ type: 'seriesArray', payload: [arguments[0]] });\n\t\t\tbreak;\n\t\tcase  'string,function': // Form: series(String <id>, func)\n\t\t\tvar payload = {};\n\t\t\tpayload[arguments[0]] = arguments[1];\n\t\t\tthis._struct.push({ type: 'seriesObject', payload: payload});\n\t\t\tbreak;\n\t\tcase 'array': // Form: series(Array <funcs>)\n\t\t\tthis._struct.push({ type: 'seriesArray', payload: arguments[0] });\n\t\t\tbreak;\n\t\tcase 'object': // Form: series(Object <funcs>)\n\t\t\tthis._struct.push({ type: 'seriesObject', payload: arguments[0] });\n\t\t\tbreak;\n\t\tcase 'collection': // Form: series(Collection <funcs>)\n\t\t\tthis._struct.push({ type: 'seriesCollection', payload: arguments[0] });\n\t\t\tbreak;\n\n\t\t// Async library compatibility {{{\n\t\tcase 'array,function':\n\t\t\tthis._struct.push({ type: 'seriesArray', payload: arguments[0] });\n\t\t\tthis.end(arguments[1]);\n\t\t\tbreak;\n\t\tcase 'object,function':\n\t\t\tthis._struct.push({ type: 'seriesObject', payload: arguments[0] });\n\t\t\tthis.end(arguments[1]);\n\t\t\tbreak;\n\t\t// }}}\n\t\tdefault:\n\t\t\tthrow new Error('Unknown call style for .series(): ' + calledAs);\n\t}\n\n\treturn this;\n};\n\n\n/**\n* Queue up a function(s) to execute in parallel\n* @param array,object,function The function(s) to execute\n* @return object This chainable object\n*/\nfunction parallel() {\n\tvar calledAs = getOverload(arguments)\n\tswitch (calledAs) {\n\t\tcase '':\n\t\t\t// Pass\n\t\t\tbreak;\n\t\tcase 'function': // Form: parallel(func)\n\t\t\tthis._struct.push({ type: 'parallelArray', payload: [arguments[0]] });\n\t\t\tbreak;\n\t\tcase 'string,function': // Form: parallel(String <id>, func)\n\t\t\tvar payload = {};\n\t\t\tpayload[arguments[0]] = arguments[1];\n\t\t\tthis._struct.push({ type: 'parallelArray', payload: payload });\n\t\t\tbreak;\n\t\tcase 'array': // Form: parallel(Array <funcs>)\n\t\t\tthis._struct.push({ type: 'parallelArray', payload: arguments[0] });\n\t\t\tbreak;\n\t\tcase 'object': // Form: parallel(Object <funcs>)\n\t\t\tthis._struct.push({ type: 'parallelObject', payload: arguments[0] });\n\t\t\tbreak;\n\t\tcase 'collection': // Form: parallel(Collection <funcs>)\n\t\t\tthis._struct.push({ type: 'parallelCollection', payload: arguments[0] });\n\t\t\tbreak;\n\n\t\t// Async library compatibility {{{\n\t\tcase 'array,function':\n\t\t\tthis._struct.push({ type: 'parallelArray', payload: arguments[0] });\n\t\t\tthis.end(arguments[1]);\n\t\t\tbreak;\n\t\tcase 'object,function':\n\t\t\tthis._struct.push({ type: 'parallelObject', payload: arguments[0] });\n\t\t\tthis.end(arguments[1]);\n\t\t\tbreak;\n\t\t// }}}\n\t\tdefault:\n\t\t\tthrow new Error('Unknown call style for .parallel(): ' + calledAs);\n\t}\n\n\treturn this;\n};\n\n\n/**\n* Run an array/object/collection though a function\n* This is similar to the async native .each() function but chainable\n*/\nfunction forEach() {\n\tvar calledAs = getOverload(arguments)\n\tswitch (calledAs) {\n\t\tcase '':\n\t\t\t// Pass\n\t\t\tbreak;\n\t\tcase 'collection,function': // Form: forEach(Collection func)\n\t\tcase 'array,function': // Form: forEach(Array, func)\n\t\t\tthis._struct.push({ type: 'forEachArray', payload: arguments[0], callback: arguments[1] });\n\t\t\tbreak;\n\t\tcase 'object,function': // Form: forEach(Object, func)\n\t\t\tthis._struct.push({ type: 'forEachObject', payload: arguments[0], callback: arguments[1] });\n\t\t\tbreak;\n\t\tcase 'string,function': // Form: forEach(String <set lookup>, func)\n\t\t\tthis._struct.push({ type: 'forEachLateBound', payload: arguments[0], callback: arguments[1] });\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new Error('Unknown call style for .forEach(): ' + calledAs);\n\t}\n\n\treturn this;\n}\n\n\n// Defer functionality - Here be dragons! {{{\n/**\n* Collection of items that have been deferred\n* @type collection {payload: function, id: null|String, prereq: [dep1, dep2...]}\n* @access private\n*/\nfunction deferAdd(id, task, parentChain) {\n\tvar self = this;\n\tparentChain.waitingOn = (parentChain.waitingOn || 0) + 1;\n\n\tif (! parentChain.waitingOnIds)\n\t\tparentChain.waitingOnIds = [];\n\tparentChain.waitingOnIds.push(id);\n\n\tself._deferred.push({\n\t\tid: id || null,\n\t\tprereq: parentChain.prereq || [],\n\t\tpayload: function(next) {\n\t\t\tself._context._id = id;\n\t\t\ttask.call(self._options.context, function(err, value) {\n\t\t\t\tif (id)\n\t\t\t\t\tself._context[id] = value;\n\t\t\t\tself._deferredRunning--;\n\t\t\t\tif (--parentChain.waitingOn == 0) {\n\t\t\t\t\tparentChain.completed = true;\n\t\t\t\t\tif (self._struct.length && self._struct[self._structPointer].type == 'await')\n\t\t\t\t\t\tself._execute(err);\n\t\t\t\t}\n\t\t\t\tself._execute(err);\n\t\t\t});\n\t\t}\n\t});\n};\n\n\nfunction _deferCheck() {\n\tvar self = this;\n\tif (self._options.limit && self._deferredRunning >= self._options.limit) return; // Already over limit\n\tself._deferred = self._deferred.filter(function(item) {\n\t\tif (self._options.limit && self._deferredRunning >= self._options.limit) {\n\t\t\treturn true; // Already over limit - all subseqent items should be left in place\n\t\t}\n\t\tif (\n\t\t\titem.prereq.length == 0 || // No pre-reqs - can execute now\n\t\t\titem.prereq.every(function(dep) { // All pre-reqs are satisfied\n\t\t\t\treturn self._context.hasOwnProperty(dep);\n\t\t\t})\n\t\t) { \n\t\t\tself._deferredRunning++;\n\t\t\tsetTimeout(item.payload);\n\t\t\treturn false;\n\t\t} else { // Can't do anything with self right now\n\t\t\treturn true;\n\t\t}\n\t});\n};\n// }}}\n\n\n/**\n* Queue up a function(s) to execute as deferred - i.e. dont stop to wait for it\n* @param array,object,function The function(s) to execute as a defer\n* @return object This chainable object\n*/\nfunction defer() {\n\tvar calledAs = getOverload(arguments);\n\tswitch (calledAs) {\n\t\tcase '':\n\t\t\t// Pass\n\t\t\tbreak;\n\t\tcase 'function': // Form: defer(func)\n\t\t\tthis._struct.push({ type: 'deferArray', payload: [arguments[0]] });\n\t\t\tbreak;\n\t\tcase 'string,function': // Form: defer(String <id>, func)\n\t\t\tvar payload = {};\n\t\t\tpayload[arguments[0]] = arguments[1];\n\t\t\tthis._struct.push({ type: 'deferObject', payload: payload });\n\t\t\tbreak;\n\t\tcase 'array': // Form: defer(Array <funcs>)\n\t\t\tthis._struct.push({ type: 'deferArray', payload: arguments[0] });\n\t\t\tbreak;\n\t\tcase 'object': // Form: defer(Object <funcs>)\n\t\t\tthis._struct.push({ type: 'deferObject', payload: arguments[0] });\n\t\t\tbreak;\n\t\tcase 'collection': // Form defer(Collection <funcs>)\n\t\t\tthis._struct.push({ type: 'deferCollection', payload: arguments[0] });\n\t\t\tbreak;\n\t\tcase 'array,function': // Form: defer(Array <prereqs>, func)\n\t\t\tthis._struct.push({ type: 'deferArray', prereq: arguments[0], payload: [arguments[1]] });\n\t\t\tbreak;\n\t\tcase 'string,string,function': // Form: defer(String <prereq>, String <name>, func)\n\t\t\tvar payload = {};\n\t\t\tpayload[arguments[1]] = arguments[2];\n\t\t\tthis._struct.push({ type: 'deferObject', prereq: [arguments[0]], payload: payload });\n\t\t\tbreak;\n\t\tcase 'array,string,function': //Form: defer(Array <prereqs>, String <id>, func)\n\t\t\tvar payload = {};\n\t\t\tpayload[arguments[1]] = arguments[2];\n\t\t\tthis._struct.push({ type: 'deferObject', prereq: arguments[0], payload: payload });\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new Error('Unknown call style for .defer():' + calledAs);\n\t}\n\n\treturn this;\n};\n\n\n/**\n* Queue up an await point\n* This stops the execution queue until its satisfied that dependencies have been resolved\n* @param array,... The dependencies to check resolution of. If omitted all are checked\n* @return object This chainable object\n*/\nfunction await() {\n\tvar payload = [];\n\n\t// Slurp all args into payload {{{\n\tvar args = arguments;\n\tgetOverload(arguments).split(',').forEach(function(type, offset) {\n\t\tswitch (type) {\n\t\t\tcase '': // Blank arguments - do nothing\n\t\t\t\t// Pass\n\t\t\t\tbreak;\n\t\t\tcase 'string':\n\t\t\t\tpayload.push(args[offset]);\n\t\t\t\tbreak;\n\t\t\tcase 'array':\n\t\t\t\tpayload.concat(args[offset]);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unknown argument type passed to .await(): ' + type);\n\t\t}\n\t});\n\t// }}}\n\n\tthis._struct.push({ type: 'await', payload: payload });\n\n\treturn this;\n};\n\n\n/**\n* Queue up a limit setter\n* @param int|null|false Either the number of defer processes that are allowed to execute simultaniously or falsy values to disable\n* @return object This chainable object\n*/\nfunction setLimit(setLimit) {\n\tthis._struct.push({ type: 'limit', payload: setLimit });\n\treturn this;\n};\n\n\n/**\n* Queue up a context setter\n* @param object newContext The new context to pass to all subsequent functions via `this`\n* @return object This chainable object\n*/\nfunction setContext(newContext) {\n\tthis._struct.push({ type: 'context', payload: newContext });\n\treturn this;\n};\n\n\n/**\n* Queue up a varable setter (i.e. set a hash of variables in context)\n* @param string The named key to set\n* @param mixed The value to set\n* @return object This chainable object\n*/\nfunction set() {\n\tvar calledAs = getOverload(arguments);\n\tswitch(calledAs) {\n\t\tcase '':\n\t\t\t// Pass\n\t\t\tbreak;\n\t\tcase 'string,string': // Form: set(String <key>, String <value>)\n\t\tcase 'string,number': // Form: set(String <key>, Number <value>)\n\t\tcase 'string,boolean': // Form: set(String <key>, Boolean <value>)\n\t\tcase 'string,array': // Form: set(String <key>, Array <value>)\n\t\tcase 'string,collection': // Form: set(String <key>, Collection <value>)\n\t\tcase 'string,object': // Form: set(String <key>, Object <value>)\n\t\t\tvar payload = {};\n\t\t\tpayload[arguments[0]] = arguments[1];\n\t\t\tthis._struct.push({ type: 'set', payload: payload });\n\t\t\tbreak;\n\t\tcase 'object': // Form: set(Object)\n\t\t\tthis._struct.push({ type: 'set', payload: arguments[0] });\n\t\t\tbreak;\n\t\tcase 'function': // Form: set(func) -> series(func)\n\t\t\tthis._struct.push({ type: 'seriesArray', payload: [arguments[0]] });\n\t\t\tbreak;\n\t\tcase  'string,function': // Form: set(String, func) -> series(String <id>, func)\n\t\t\tvar payload = {};\n\t\t\tpayload[arguments[0]] = arguments[1];\n\t\t\tthis._struct.push({ type: 'seriesObject', payload: payload});\n\t\t\tbreak;\n\t\tcase 'string': // Set to undefined\n\t\t\tthis._setRaw(arguments[0], undefined);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new Error('Unknown call style for .set():' + calledAs);\n\t}\n\n\treturn this;\n};\n\n\n/**\n* Set a context items value\n* Not to be confused with `set()` which is the chainable external visible version of this\n* Unlike `set()` this function sets an item of _context immediately\n* @access private\n* @see _setRaw()\n*/\nfunction _set() {\n\tvar calledAs = getOverload(arguments);\n\tswitch(calledAs) {\n\t\tcase '':\n\t\t\t// Pass\n\t\t\tbreak;\n\t\tcase 'string,string': // Form: set(String <key>, String <value>)\n\t\tcase 'string,number': // Form: set(String <key>, Number <value>)\n\t\tcase 'string,boolean': // Form: set(String <key>, Boolean <value>)\n\t\tcase 'string,array': // Form: set(String <key>, Array <value>)\n\t\tcase 'string,collection': // Form: set(String <key>, Collection <value>)\n\t\tcase 'string,object': // Form: set(String <key>, Object <value>)\n\t\t\tthis._setRaw(arguments[0], arguments[1]);\n\t\t\tbreak;\n\t\tcase 'object': // Form: set(Object)\n\t\t\tfor (var key in arguments[0])\n\t\t\t\tthis._setRaw(key, arguments[0][key]);\n\t\t\tbreak;\n\t\tcase  'string,function': // Form: set(String, func) -> series(String <id>, func)\n\t\t\tthis._setRaw(arguments[0], arguments[1].call(this));\n\t\t\tbreak;\n\t\tcase 'function': // Form: _set(func) // Expect func to return something which is then processed to _set\n\t\t\tthis._set(arguments[1].call(this));\n\t\t\tbreak;\n\t\tcase 'string': // Set to undefined\n\t\t\tthis._setRaw(arguments[0], undefined);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new Error('Unknown call style for .set():' + calledAs);\n\t}\n\n\treturn this;\n}\n\n\n/**\n* Actual raw value setter\n* This function is the internal version of _set which takes exactly two values, the key and the value to set\n* Override this function if some alternative _context platform is required\n* @param string key The key within _context to set the value of\n* @param mixed value The value within _context[key] to set the value of\n* @access private\n*/\nfunction _setRaw(key, value) {\n\tthis._context[key] = value;\n\treturn this;\n}\n\n\n/**\n* Internal function executed at the end of the chain\n* This can occur either in sequence (i.e. no errors) or a jump to this position (i.e. an error happened somewhere)\n* @access private\n*/\nfunction _finalize(err) {\n\t// Sanity checks {{{\n\tif (this._struct.length == 0) return; // Finalize called on dead object - probably a defer() fired without an await()\n\tif (this._struct[this._struct.length - 1].type != 'end') {\n\t\tthrow new Error('While trying to find an end point in the async-chainable structure the last item in the this._struct does not have type==end!');\n\t\treturn;\n\t}\n\t// }}}\n\tthis._struct[this._struct.length-1].payload.call(this._options.context, err);\n\tif (this._options.autoReset)\n\t\tthis.reset();\n};\n\n\n/**\n* Internal function to execute the next pending queue item\n* This is usually called after the completion of every async.series() / async.parallel() / asyncChainable._run call\n* @access private\n*/\nfunction _execute(err) {\n\tvar self = this;\n\tif (err) return this._finalize(err); // An error has been raised - stop exec and call finalize now\n\tdo {\n\t\tvar redo = false;\n\t\tif (self._structPointer >= self._struct.length) return this._finalize(err); // Nothing more to execute in struct\n\t\tself._deferCheck(); // Kick off any pending deferred items\n\t\tvar currentExec = self._struct[self._structPointer];\n\t\t// Sanity checks {{{\n\t\tif (!currentExec.type) {\n\t\t\tthrow new Error('No type is specified for async-chainable structure at offset ' + self._structPointer);\n\t\t\treturn self;\n\t\t}\n\t\t// }}}\n\t\tself._structPointer++;\n\n\t\t// Skip step when function supports skipping if the argument is empty {{{\n\t\tif (\n\t\t\t[\n\t\t\t\t'parallelArray', 'parallelObject', 'parallelCollection',\n\t\t\t\t'forEachArray', 'forEachObject',\n\t\t\t\t'seriesArray', 'seriesObject', 'seriesCollection',\n\t\t\t\t'deferArray', 'deferObject', 'deferCollection',\n\t\t\t\t'set'\n\t\t\t].indexOf(currentExec.type) > -1 &&\n\t\t\t(\n\t\t\t\t!currentExec.payload || // Not set OR\n\t\t\t\t(isArray(currentExec.payload) && !currentExec.payload.length) || // An empty array\n\t\t\t\t(isObject(currentExec.payload) && !Object.keys(currentExec.payload).length) // An empty object\n\t\t\t)\n\t\t) {\n\t\t\tcurrentExec.completed = true;\n\t\t\tredo = true;\n\t\t\tcontinue;\n\t\t}\n\t\t// }}}\n\n\t\tswitch (currentExec.type) {\n\t\t\tcase 'parallelArray':\n\t\t\t\tself._run(currentExec.payload.map(function(task) {\n\t\t\t\t\treturn function(next) {\n\t\t\t\t\t\ttask.call(self._options.context, next);\n\t\t\t\t\t};\n\t\t\t\t}), self._options.limit, function(err) {\n\t\t\t\t\tcurrentExec.completed = true;\n\t\t\t\t\tself._execute(err);\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase 'parallelObject':\n\t\t\t\tvar tasks = [];\n\t\t\t\tObject.keys(currentExec.payload).forEach(function(key) {\n\t\t\t\t\ttasks.push(function(next) {\n\t\t\t\t\t\tcurrentExec.payload[key].call(self._options.context, function(err, value) {\n\t\t\t\t\t\t\tself._set(key, value); // Allocate returned value to context\n\t\t\t\t\t\t\tnext(err);\n\t\t\t\t\t\t})\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\tself._run(tasks, self._options.limit, function(err) {\n\t\t\t\t\tcurrentExec.completed = true;\n\t\t\t\t\tself._execute(err);\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase 'parallelCollection':\n\t\t\t\tvar tasks = [];\n\t\t\t\tcurrentExec.payload.forEach(function(task) {\n\t\t\t\t\tObject.keys(task).forEach(function(key) {\n\t\t\t\t\t\ttasks.push(function(next, err) {\n\t\t\t\t\t\t\tif (typeof task[key] != 'function') throw new Error('Collection item for parallel exec is not a function', currentExec.payload);\n\t\t\t\t\t\t\ttask[key].call(self._options.context, function(err, value) {\n\t\t\t\t\t\t\t\tself._set(key, value); // Allocate returned value to context\n\t\t\t\t\t\t\t\tnext(err);\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\tself._run(tasks, self._options.limit, function(err) {\n\t\t\t\t\tcurrentExec.completed = true;\n\t\t\t\t\tself._execute(err);\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase 'forEachArray':\n\t\t\t\tself._run(currentExec.payload.map(function(item, iter) {\n\t\t\t\t\tself._context._item = item;\n\t\t\t\t\tself._context._key = iter;\n\t\t\t\t\treturn function(next) {\n\t\t\t\t\t\tcurrentExec.callback.call(self._options.context, next, item, iter);\n\t\t\t\t\t};\n\t\t\t\t}), self._options.limit, function(err) {\n\t\t\t\t\tcurrentExec.completed = true;\n\t\t\t\t\tself._execute(err);\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase 'forEachObject':\n\t\t\t\tvar tasks = [];\n\t\t\t\tObject.keys(currentExec.payload).forEach(function(key) {\n\t\t\t\t\ttasks.push(function(next) {\n\t\t\t\t\t\tself._context._item = currentExec.payload[key];\n\t\t\t\t\t\tself._context._key = key;\n\t\t\t\t\t\tcurrentExec.callback.call(self._options.context, function(err, value) {\n\t\t\t\t\t\t\tself._set(key, value); // Allocate returned value to context\n\t\t\t\t\t\t\tnext(err);\n\t\t\t\t\t\t}, currentExec.payload[key], key);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\tself._run(tasks, self._options.limit, function(err) {\n\t\t\t\t\tcurrentExec.completed = true;\n\t\t\t\t\tself._execute(err);\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase 'forEachLateBound':\n\t\t\t\tif (\n\t\t\t\t\t(!currentExec.payload || !currentExec.payload.length) || // Payload is blank\n\t\t\t\t\t(!self._context[currentExec.payload]) // Payload doesnt exist within context\n\t\t\t\t) { // Goto next chain\n\t\t\t\t\tcurrentExec.completed = true;\n\t\t\t\t\tredo = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// Replace own exec array with actual type of payload now we know what it is {{{\n\t\t\t\tvar overloadType = getOverload([self._context[currentExec.payload]]);\n\t\t\t\tswitch (overloadType) {\n\t\t\t\t\tcase 'collection':\n\t\t\t\t\tcase 'array':\n\t\t\t\t\t\tcurrentExec.type = 'forEachArray';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'object':\n\t\t\t\t\t\tcurrentExec.type = 'forEachObject';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error('Cannot perform forEach over unknown object type: ' + overloadType);\n\t\t\t\t}\n\t\t\t\tcurrentExec.payload = self._context[currentExec.payload];\n\t\t\t\tself._structPointer--; // Force re-eval of this chain item now its been replace with its real (late-bound) type\n\t\t\t\tredo = true;\n\t\t\t\t// }}}\n\t\t\t\tbreak;\n\t\t\tcase 'seriesArray':\n\t\t\t\tself._run(currentExec.payload.map(function(task) {\n\t\t\t\t\treturn function(next) {\n\t\t\t\t\t\ttask.call(self._options.context, next);\n\t\t\t\t\t};\n\t\t\t\t}), 1, function(err) {\n\t\t\t\t\tcurrentExec.completed = true;\n\t\t\t\t\tself._execute(err);\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase 'seriesObject':\n\t\t\t\tvar tasks = [];\n\t\t\t\tObject.keys(currentExec.payload).forEach(function(key) {\n\t\t\t\t\ttasks.push(function(next) {\n\t\t\t\t\t\tcurrentExec.payload[key].call(self._options.context, function(err, value) {\n\t\t\t\t\t\t\tself._set(key, value); // Allocate returned value to context\n\t\t\t\t\t\t\tnext(err);\n\t\t\t\t\t\t})\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\tself._run(tasks, 1, function(err) {\n\t\t\t\t\tcurrentExec.completed = true;\n\t\t\t\t\tself._execute(err);\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase 'seriesCollection':\n\t\t\t\tvar tasks = [];\n\t\t\t\tcurrentExec.payload.forEach(function(task) {\n\t\t\t\t\tObject.keys(task).forEach(function(key) {\n\t\t\t\t\t\ttasks.push(function(next, err) {\n\t\t\t\t\t\t\tif (typeof task[key] != 'function') throw new Error('Collection item for series exec is not a function', currentExec.payload);\n\t\t\t\t\t\t\ttask[key].call(self._options.context, function(err, value) {\n\t\t\t\t\t\t\t\tself._set(key, value); // Allocate returned value to context\n\t\t\t\t\t\t\t\tnext(err);\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\tself._run(tasks, 1, function(err) {\n\t\t\t\t\tcurrentExec.completed = true;\n\t\t\t\t\tself._execute(err);\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase 'deferArray':\n\t\t\t\tcurrentExec.payload.forEach(function(task) {\n\t\t\t\t\tself._deferAdd(null, task, currentExec);\n\t\t\t\t});\n\n\t\t\t\tredo = true;\n\t\t\t\tbreak;\n\t\t\tcase 'deferObject':\n\t\t\t\tObject.keys(currentExec.payload).forEach(function(key) {\n\t\t\t\t\tself._deferAdd(key, currentExec.payload[key], currentExec);\n\t\t\t\t});\n\n\t\t\t\tredo = true;\n\t\t\t\tbreak;\n\t\t\tcase 'deferCollection':\n\t\t\t\tcurrentExec.payload.forEach(function(task) {\n\t\t\t\t\tObject.keys(task).forEach(function(key) {\n\t\t\t\t\t\tself._deferAdd(key, task[key], currentExec);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\tredo = true;\n\t\t\t\tbreak;\n\t\t\tcase 'await': // Await can operate in two modes, either payload=[] (examine all) else (examine specific keys)\n\t\t\t\tif (!currentExec.payload.length) { // Check all tasks are complete\n\t\t\t\t\tif (self._struct.slice(0, self._structPointer - 1).every(function(stage) { // Examine all items UP TO self one and check they are complete\n\t\t\t\t\t\treturn stage.completed;\n\t\t\t\t\t})) { // All tasks up to self point are marked as completed\n\t\t\t\t\t\tcurrentExec.completed = true;\n\t\t\t\t\t\tredo = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._structPointer--; // At least one task is outstanding - rewind to self stage so we repeat on next resolution\n\t\t\t\t\t}\n\t\t\t\t} else { // Check certain tasks are complete by key\n\t\t\t\t\tif (currentExec.payload.every(function(dep) { // Examine all named dependencies\n\t\t\t\t\t\treturn !! self._context[dep];\n\t\t\t\t\t})) { // All are present\n\t\t\t\t\t\tcurrentExec.completed = true;\n\t\t\t\t\t\tredo = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself._structPointer--; // At least one dependency is outstanding - rewind to self stage so we repeat on next resolution\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'limit': // Set the options.limit variable\n\t\t\t\tself._options.limit = currentExec.payload;\n\t\t\t\tcurrentExec.completed = true;\n\t\t\t\tredo = true; // Move on to next action\n\t\t\t\tbreak;\n\t\t\tcase 'context': // Change the self._options.context object\n\t\t\t\tself._options.context = currentExec.payload ? currentExec.payload : self._context; // Set context (if null use internal context)\n\t\t\t\tcurrentExec.completed = true;\n\t\t\t\tredo = true; // Move on to next action\n\t\t\t\tbreak;\n\t\t\tcase 'set': // Set a hash of variables within context\n\t\t\t\tObject.keys(currentExec.payload).forEach(function(key) {\n\t\t\t\t\tself._set(key, currentExec.payload[key]);\n\t\t\t\t});\n\t\t\t\tcurrentExec.completed = true;\n\t\t\t\tredo = true; // Move on to next action\n\t\t\t\tbreak;\n\t\t\tcase 'end': // self should ALWAYS be the last item in the structure and indicates the final function call\n\t\t\t\tthis._finalize();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (this._plugins[currentExec.type]) { // Is there a plugin that should manage this?\n\t\t\t\t\tthis._plugins[currentExec.type].call(this, currentExec);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error('Unknown async-chainable exec type: ' + currentExec.type);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t}\n\t} while (redo);\n};\n\n\n/**\n* Internal function to run an array of functions (usually in parallel)\n* Series execution can be obtained by setting limit = 1\n* @param array tasks The array of tasks to execute\n* @param int limit The limiter of tasks (if limit==1 tasks are run in series, if limit>1 tasks are run in limited parallel, else tasks are run in parallel)\n* @param function callback(err) The callback to fire on finish\n*/\nfunction _run(tasks, limit, callback) {\n\tif (limit == 1) {\n\t\tasync.series(tasks, callback);\n\t} else if (limit > 0) {\n\t\tasync.parallelLimit(tasks, limit, callback);\n\t} else {\n\t\tasync.parallel(tasks, callback);\n\t}\n}\n\n\n/**\n* Reset all state variables and return the object into a pristine condition\n* @return object This chainable object\n*/\nfunction reset() {\n\tthis._struct = [];\n\tthis._structPointer = 0;\n\n\tvar reAttachContext = (this._options.context == this._context); // Reattach the context pointer after reset?\n\tthis._context = {\n\t\t_struct: this._struct,\n\t\t_structPointer: this._structPointer,\n\t\t_options: this._options,\n\t\t_deferredRunning: this._deferredRunning,\n\t};\n\n\tif (reAttachContext) this._options.context = this._context;\n};\n\n/**\n* Queue up an optional single function for execution on completion\n* This function also starts the queue executing\n* @return object This chainable object\n*/\nfunction end() { \n\tvar calledAs = getOverload(arguments);\n\tswitch (calledAs) {\n\t\tcase '': // No functions passed - do nothing\n\t\t\tthis._struct.push({ type: 'end', payload: function() {} }); // .end() called with no args - make a noop()\n\t\t\tbreak;\n\t\tcase 'function': // Form: end(func) -> redirect as if called with series(func)\n\t\t\tthis._struct.push({ type: 'end', payload: arguments[0] });\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new Error('Unknown call style for .end(): ' + calledAs);\n\t}\n\n\tthis._execute();\n\treturn this;\n};\n\nvar objectInstance = function() {\n\t// Variables {{{\n\tthis._struct = [];\n\tthis._structPointer = 0;\n\tthis._context = {};\n\n\tthis._options = {\n\t\tautoReset: true, // Run asyncChainable.reset() after finalize. Disable this if you want to see a post-mortem on what did run\n\t\tlimit: 10, // Number of defer functions that are allowed to execute at once\n\t\tcontext: this._context, // The context item passed to the functions (can be changed with .context())\n\t};\n\t// }}}\n\n\t// Async-Chainable functions {{{\n\t// Private {{{\n\tthis._execute = _execute;\n\tthis._run = _run;\n\tthis._deferCheck = _deferCheck;\n\tthis._deferAdd = deferAdd;\n\tthis._deferred = [];\n\tthis._deferredRunning = 0;\n\tthis._finalize = _finalize;\n\tthis._getOverload = getOverload; // So this function is accessible by plugins\n\tthis._plugins = _plugins;\n\t// }}}\n\n\tthis.await = await;\n\tthis.context = setContext;\n\tthis.defer = defer;\n\tthis.end = end;\n\tthis.forEach = forEach;\n\tthis.limit = setLimit;\n\tthis.parallel = parallel;\n\tthis.reset = reset;\n\tthis.series = series;\n\tthis.set = set;\n\tthis._set = _set;\n\tthis._setRaw = _setRaw;\n\tthis.then = series;\n\tthis.new = function() { return new objectInstance };\n\tthis.use = use;\n\t// }}}\n\n\t// Async compat functionality - so this module becomes a drop-in replacement {{{\n\t// Collections\n\tthis.each = async.each;\n\tthis.eachSeries = async.eachSeries;\n\tthis.eachLimit = async.eachLimit;\n\tthis.map = async.map;\n\tthis.mapSeries = async.mapSeries;\n\tthis.mapLimit = async.mapLimit;\n\tthis.filter = async.filter;\n\tthis.filterSeries = async.filterSeries;\n\tthis.reject = async.reject;\n\tthis.rejectSeries = async.rejectSeries;\n\tthis.reduce = async.reduce;\n\tthis.reduceRight = async.reduceRight;\n\tthis.detect = async.detect;\n\tthis.detectSeries = async.detectSeries;\n\tthis.sortBy = async.sortBy;\n\tthis.some = async.some;\n\tthis.every = async.every;\n\tthis.concat = async.concat;\n\tthis.concatSeries = async.concatSeries;\n\n\t// Control Flow\n\t// See main .series() and .parallel() code for async compatibility\n\tthis.parallelLimit = async.parallelLimit;\n\tthis.whilst = async.whilst;\n\tthis.doWhilst = async.doWhilst;\n\tthis.until = async.until;\n\tthis.doUntil = async.doUntil;\n\tthis.forever = async.forever;\n\tthis.waterfall = async.waterfall;\n\tthis.compose = async.compose;\n\tthis.seq = async.seq;\n\tthis.applyEach = async.applyEach;\n\tthis.applyEachSeries = async.applyEachSeries;\n\tthis.queue = async.queue;\n\tthis.priorityQueue = async.priorityQueue;\n\tthis.cargo = async.cargo;\n\tthis.auto = async.auto;\n\tthis.retry = async.retry;\n\tthis.iterator = async.iterator;\n\tthis.apply = async.apply;\n\tthis.nextTick = async.nextTick;\n\tthis.times = async.times;\n\tthis.timesSeries = async.timesSeries;\n\tthis.Utils = async.Utils;\n\n\t// Utils\n\tthis.memoize = async.memoize;\n\tthis.unmemoize = async.unmemoize;\n\tthis.log = async.log;\n\tthis.dir = async.dir;\n\tthis.noConflict = async.noConflict;\n\t// }}}\n\n\tthis.reset();\n\treturn this;\n}\n\n// Return the output object\nmodule.exports = function asyncChainable() {\n\treturn new objectInstance;\n};\n\n},{\"async\":3}],3:[function(require,module,exports){\n(function (process,global){\n/*!\n * async\n * https://github.com/caolan/async\n *\n * Copyright 2010-2014 Caolan McMahon\n * Released under the MIT license\n */\n(function () {\n\n    var async = {};\n    function noop() {}\n    function identity(v) {\n        return v;\n    }\n    function toBool(v) {\n        return !!v;\n    }\n    function notId(v) {\n        return !v;\n    }\n\n    // global on the server, window in the browser\n    var previous_async;\n\n    // Establish the root object, `window` (`self`) in the browser, `global`\n    // on the server, or `this` in some virtual machines. We use `self`\n    // instead of `window` for `WebWorker` support.\n    var root = typeof self === 'object' && self.self === self && self ||\n            typeof global === 'object' && global.global === global && global ||\n            this;\n\n    if (root != null) {\n        previous_async = root.async;\n    }\n\n    async.noConflict = function () {\n        root.async = previous_async;\n        return async;\n    };\n\n    function only_once(fn) {\n        return function() {\n            if (fn === null) throw new Error(\"Callback was already called.\");\n            fn.apply(this, arguments);\n            fn = null;\n        };\n    }\n\n    function _once(fn) {\n        return function() {\n            if (fn === null) return;\n            fn.apply(this, arguments);\n            fn = null;\n        };\n    }\n\n    //// cross-browser compatiblity functions ////\n\n    var _toString = Object.prototype.toString;\n\n    var _isArray = Array.isArray || function (obj) {\n        return _toString.call(obj) === '[object Array]';\n    };\n\n    // Ported from underscore.js isObject\n    var _isObject = function(obj) {\n        var type = typeof obj;\n        return type === 'function' || type === 'object' && !!obj;\n    };\n\n    function _isArrayLike(arr) {\n        return _isArray(arr) || (\n            // has a positive integer length property\n            typeof arr.length === \"number\" &&\n            arr.length >= 0 &&\n            arr.length % 1 === 0\n        );\n    }\n\n    function _arrayEach(arr, iterator) {\n        var index = -1,\n            length = arr.length;\n\n        while (++index < length) {\n            iterator(arr[index], index, arr);\n        }\n    }\n\n    function _map(arr, iterator) {\n        var index = -1,\n            length = arr.length,\n            result = Array(length);\n\n        while (++index < length) {\n            result[index] = iterator(arr[index], index, arr);\n        }\n        return result;\n    }\n\n    function _range(count) {\n        return _map(Array(count), function (v, i) { return i; });\n    }\n\n    function _reduce(arr, iterator, memo) {\n        _arrayEach(arr, function (x, i, a) {\n            memo = iterator(memo, x, i, a);\n        });\n        return memo;\n    }\n\n    function _forEachOf(object, iterator) {\n        _arrayEach(_keys(object), function (key) {\n            iterator(object[key], key);\n        });\n    }\n\n    function _indexOf(arr, item) {\n        for (var i = 0; i < arr.length; i++) {\n            if (arr[i] === item) return i;\n        }\n        return -1;\n    }\n\n    var _keys = Object.keys || function (obj) {\n        var keys = [];\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                keys.push(k);\n            }\n        }\n        return keys;\n    };\n\n    function _keyIterator(coll) {\n        var i = -1;\n        var len;\n        var keys;\n        if (_isArrayLike(coll)) {\n            len = coll.length;\n            return function next() {\n                i++;\n                return i < len ? i : null;\n            };\n        } else {\n            keys = _keys(coll);\n            len = keys.length;\n            return function next() {\n                i++;\n                return i < len ? keys[i] : null;\n            };\n        }\n    }\n\n    // Similar to ES6's rest param (http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html)\n    // This accumulates the arguments passed into an array, after a given index.\n    // From underscore.js (https://github.com/jashkenas/underscore/pull/2140).\n    function _restParam(func, startIndex) {\n        startIndex = startIndex == null ? func.length - 1 : +startIndex;\n        return function() {\n            var length = Math.max(arguments.length - startIndex, 0);\n            var rest = Array(length);\n            for (var index = 0; index < length; index++) {\n                rest[index] = arguments[index + startIndex];\n            }\n            switch (startIndex) {\n                case 0: return func.call(this, rest);\n                case 1: return func.call(this, arguments[0], rest);\n            }\n            // Currently unused but handle cases outside of the switch statement:\n            // var args = Array(startIndex + 1);\n            // for (index = 0; index < startIndex; index++) {\n            //     args[index] = arguments[index];\n            // }\n            // args[startIndex] = rest;\n            // return func.apply(this, args);\n        };\n    }\n\n    function _withoutIndex(iterator) {\n        return function (value, index, callback) {\n            return iterator(value, callback);\n        };\n    }\n\n    //// exported async module functions ////\n\n    //// nextTick implementation with browser-compatible fallback ////\n\n    // capture the global reference to guard against fakeTimer mocks\n    var _setImmediate = typeof setImmediate === 'function' && setImmediate;\n\n    var _delay = _setImmediate ? function(fn) {\n        // not a direct alias for IE10 compatibility\n        _setImmediate(fn);\n    } : function(fn) {\n        setTimeout(fn, 0);\n    };\n\n    if (typeof process === 'object' && typeof process.nextTick === 'function') {\n        async.nextTick = process.nextTick;\n    } else {\n        async.nextTick = _delay;\n    }\n    async.setImmediate = _setImmediate ? _delay : async.nextTick;\n\n\n    async.forEach =\n    async.each = function (arr, iterator, callback) {\n        return async.eachOf(arr, _withoutIndex(iterator), callback);\n    };\n\n    async.forEachSeries =\n    async.eachSeries = function (arr, iterator, callback) {\n        return async.eachOfSeries(arr, _withoutIndex(iterator), callback);\n    };\n\n\n    async.forEachLimit =\n    async.eachLimit = function (arr, limit, iterator, callback) {\n        return _eachOfLimit(limit)(arr, _withoutIndex(iterator), callback);\n    };\n\n    async.forEachOf =\n    async.eachOf = function (object, iterator, callback) {\n        callback = _once(callback || noop);\n        object = object || [];\n\n        var iter = _keyIterator(object);\n        var key, completed = 0;\n\n        while ((key = iter()) != null) {\n            completed += 1;\n            iterator(object[key], key, only_once(done));\n        }\n\n        if (completed === 0) callback(null);\n\n        function done(err) {\n            completed--;\n            if (err) {\n                callback(err);\n            }\n            // Check key is null in case iterator isn't exhausted\n            // and done resolved synchronously.\n            else if (key === null && completed <= 0) {\n                callback(null);\n            }\n        }\n    };\n\n    async.forEachOfSeries =\n    async.eachOfSeries = function (obj, iterator, callback) {\n        callback = _once(callback || noop);\n        obj = obj || [];\n        var nextKey = _keyIterator(obj);\n        var key = nextKey();\n        function iterate() {\n            var sync = true;\n            if (key === null) {\n                return callback(null);\n            }\n            iterator(obj[key], key, only_once(function (err) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    key = nextKey();\n                    if (key === null) {\n                        return callback(null);\n                    } else {\n                        if (sync) {\n                            async.setImmediate(iterate);\n                        } else {\n                            iterate();\n                        }\n                    }\n                }\n            }));\n            sync = false;\n        }\n        iterate();\n    };\n\n\n\n    async.forEachOfLimit =\n    async.eachOfLimit = function (obj, limit, iterator, callback) {\n        _eachOfLimit(limit)(obj, iterator, callback);\n    };\n\n    function _eachOfLimit(limit) {\n\n        return function (obj, iterator, callback) {\n            callback = _once(callback || noop);\n            obj = obj || [];\n            var nextKey = _keyIterator(obj);\n            if (limit <= 0) {\n                return callback(null);\n            }\n            var done = false;\n            var running = 0;\n            var errored = false;\n\n            (function replenish () {\n                if (done && running <= 0) {\n                    return callback(null);\n                }\n\n                while (running < limit && !errored) {\n                    var key = nextKey();\n                    if (key === null) {\n                        done = true;\n                        if (running <= 0) {\n                            callback(null);\n                        }\n                        return;\n                    }\n                    running += 1;\n                    iterator(obj[key], key, only_once(function (err) {\n                        running -= 1;\n                        if (err) {\n                            callback(err);\n                            errored = true;\n                        }\n                        else {\n                            replenish();\n                        }\n                    }));\n                }\n            })();\n        };\n    }\n\n\n    function doParallel(fn) {\n        return function (obj, iterator, callback) {\n            return fn(async.eachOf, obj, iterator, callback);\n        };\n    }\n    function doParallelLimit(fn) {\n        return function (obj, limit, iterator, callback) {\n            return fn(_eachOfLimit(limit), obj, iterator, callback);\n        };\n    }\n    function doSeries(fn) {\n        return function (obj, iterator, callback) {\n            return fn(async.eachOfSeries, obj, iterator, callback);\n        };\n    }\n\n    function _asyncMap(eachfn, arr, iterator, callback) {\n        callback = _once(callback || noop);\n        arr = arr || [];\n        var results = _isArrayLike(arr) ? [] : {};\n        eachfn(arr, function (value, index, callback) {\n            iterator(value, function (err, v) {\n                results[index] = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, results);\n        });\n    }\n\n    async.map = doParallel(_asyncMap);\n    async.mapSeries = doSeries(_asyncMap);\n    async.mapLimit = doParallelLimit(_asyncMap);\n\n    // reduce only has a series version, as doing reduce in parallel won't\n    // work in many situations.\n    async.inject =\n    async.foldl =\n    async.reduce = function (arr, memo, iterator, callback) {\n        async.eachOfSeries(arr, function (x, i, callback) {\n            iterator(memo, x, function (err, v) {\n                memo = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, memo);\n        });\n    };\n\n    async.foldr =\n    async.reduceRight = function (arr, memo, iterator, callback) {\n        var reversed = _map(arr, identity).reverse();\n        async.reduce(reversed, memo, iterator, callback);\n    };\n\n    async.transform = function (arr, memo, iterator, callback) {\n        if (arguments.length === 3) {\n            callback = iterator;\n            iterator = memo;\n            memo = _isArray(arr) ? [] : {};\n        }\n\n        async.eachOf(arr, function(v, k, cb) {\n            iterator(memo, v, k, cb);\n        }, function(err) {\n            callback(err, memo);\n        });\n    };\n\n    function _filter(eachfn, arr, iterator, callback) {\n        var results = [];\n        eachfn(arr, function (x, index, callback) {\n            iterator(x, function (v) {\n                if (v) {\n                    results.push({index: index, value: x});\n                }\n                callback();\n            });\n        }, function () {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    }\n\n    async.select =\n    async.filter = doParallel(_filter);\n\n    async.selectLimit =\n    async.filterLimit = doParallelLimit(_filter);\n\n    async.selectSeries =\n    async.filterSeries = doSeries(_filter);\n\n    function _reject(eachfn, arr, iterator, callback) {\n        _filter(eachfn, arr, function(value, cb) {\n            iterator(value, function(v) {\n                cb(!v);\n            });\n        }, callback);\n    }\n    async.reject = doParallel(_reject);\n    async.rejectLimit = doParallelLimit(_reject);\n    async.rejectSeries = doSeries(_reject);\n\n    function _createTester(eachfn, check, getResult) {\n        return function(arr, limit, iterator, cb) {\n            function done() {\n                if (cb) cb(getResult(false, void 0));\n            }\n            function iteratee(x, _, callback) {\n                if (!cb) return callback();\n                iterator(x, function (v) {\n                    if (cb && check(v)) {\n                        cb(getResult(true, x));\n                        cb = iterator = false;\n                    }\n                    callback();\n                });\n            }\n            if (arguments.length > 3) {\n                eachfn(arr, limit, iteratee, done);\n            } else {\n                cb = iterator;\n                iterator = limit;\n                eachfn(arr, iteratee, done);\n            }\n        };\n    }\n\n    async.any =\n    async.some = _createTester(async.eachOf, toBool, identity);\n\n    async.someLimit = _createTester(async.eachOfLimit, toBool, identity);\n\n    async.all =\n    async.every = _createTester(async.eachOf, notId, notId);\n\n    async.everyLimit = _createTester(async.eachOfLimit, notId, notId);\n\n    function _findGetResult(v, x) {\n        return x;\n    }\n    async.detect = _createTester(async.eachOf, identity, _findGetResult);\n    async.detectSeries = _createTester(async.eachOfSeries, identity, _findGetResult);\n    async.detectLimit = _createTester(async.eachOfLimit, identity, _findGetResult);\n\n    async.sortBy = function (arr, iterator, callback) {\n        async.map(arr, function (x, callback) {\n            iterator(x, function (err, criteria) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    callback(null, {value: x, criteria: criteria});\n                }\n            });\n        }, function (err, results) {\n            if (err) {\n                return callback(err);\n            }\n            else {\n                callback(null, _map(results.sort(comparator), function (x) {\n                    return x.value;\n                }));\n            }\n\n        });\n\n        function comparator(left, right) {\n            var a = left.criteria, b = right.criteria;\n            return a < b ? -1 : a > b ? 1 : 0;\n        }\n    };\n\n    async.auto = function (tasks, concurrency, callback) {\n        if (typeof arguments[1] === 'function') {\n            // concurrency is optional, shift the args.\n            callback = concurrency;\n            concurrency = null;\n        }\n        callback = _once(callback || noop);\n        var keys = _keys(tasks);\n        var remainingTasks = keys.length;\n        if (!remainingTasks) {\n            return callback(null);\n        }\n        if (!concurrency) {\n            concurrency = remainingTasks;\n        }\n\n        var results = {};\n        var runningTasks = 0;\n\n        var hasError = false;\n\n        var listeners = [];\n        function addListener(fn) {\n            listeners.unshift(fn);\n        }\n        function removeListener(fn) {\n            var idx = _indexOf(listeners, fn);\n            if (idx >= 0) listeners.splice(idx, 1);\n        }\n        function taskComplete() {\n            remainingTasks--;\n            _arrayEach(listeners.slice(0), function (fn) {\n                fn();\n            });\n        }\n\n        addListener(function () {\n            if (!remainingTasks) {\n                callback(null, results);\n            }\n        });\n\n        _arrayEach(keys, function (k) {\n            if (hasError) return;\n            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];\n            var taskCallback = _restParam(function(err, args) {\n                runningTasks--;\n                if (args.length <= 1) {\n                    args = args[0];\n                }\n                if (err) {\n                    var safeResults = {};\n                    _forEachOf(results, function(val, rkey) {\n                        safeResults[rkey] = val;\n                    });\n                    safeResults[k] = args;\n                    hasError = true;\n\n                    callback(err, safeResults);\n                }\n                else {\n                    results[k] = args;\n                    async.setImmediate(taskComplete);\n                }\n            });\n            var requires = task.slice(0, task.length - 1);\n            // prevent dead-locks\n            var len = requires.length;\n            var dep;\n            while (len--) {\n                if (!(dep = tasks[requires[len]])) {\n                    throw new Error('Has nonexistent dependency in ' + requires.join(', '));\n                }\n                if (_isArray(dep) && _indexOf(dep, k) >= 0) {\n                    throw new Error('Has cyclic dependencies');\n                }\n            }\n            function ready() {\n                return runningTasks < concurrency && _reduce(requires, function (a, x) {\n                    return (a && results.hasOwnProperty(x));\n                }, true) && !results.hasOwnProperty(k);\n            }\n            if (ready()) {\n                runningTasks++;\n                task[task.length - 1](taskCallback, results);\n            }\n            else {\n                addListener(listener);\n            }\n            function listener() {\n                if (ready()) {\n                    runningTasks++;\n                    removeListener(listener);\n                    task[task.length - 1](taskCallback, results);\n                }\n            }\n        });\n    };\n\n\n\n    async.retry = function(times, task, callback) {\n        var DEFAULT_TIMES = 5;\n        var DEFAULT_INTERVAL = 0;\n\n        var attempts = [];\n\n        var opts = {\n            times: DEFAULT_TIMES,\n            interval: DEFAULT_INTERVAL\n        };\n\n        function parseTimes(acc, t){\n            if(typeof t === 'number'){\n                acc.times = parseInt(t, 10) || DEFAULT_TIMES;\n            } else if(typeof t === 'object'){\n                acc.times = parseInt(t.times, 10) || DEFAULT_TIMES;\n                acc.interval = parseInt(t.interval, 10) || DEFAULT_INTERVAL;\n            } else {\n                throw new Error('Unsupported argument type for \\'times\\': ' + typeof t);\n            }\n        }\n\n        var length = arguments.length;\n        if (length < 1 || length > 3) {\n            throw new Error('Invalid arguments - must be either (task), (task, callback), (times, task) or (times, task, callback)');\n        } else if (length <= 2 && typeof times === 'function') {\n            callback = task;\n            task = times;\n        }\n        if (typeof times !== 'function') {\n            parseTimes(opts, times);\n        }\n        opts.callback = callback;\n        opts.task = task;\n\n        function wrappedTask(wrappedCallback, wrappedResults) {\n            function retryAttempt(task, finalAttempt) {\n                return function(seriesCallback) {\n                    task(function(err, result){\n                        seriesCallback(!err || finalAttempt, {err: err, result: result});\n                    }, wrappedResults);\n                };\n            }\n\n            function retryInterval(interval){\n                return function(seriesCallback){\n                    setTimeout(function(){\n                        seriesCallback(null);\n                    }, interval);\n                };\n            }\n\n            while (opts.times) {\n\n                var finalAttempt = !(opts.times-=1);\n                attempts.push(retryAttempt(opts.task, finalAttempt));\n                if(!finalAttempt && opts.interval > 0){\n                    attempts.push(retryInterval(opts.interval));\n                }\n            }\n\n            async.series(attempts, function(done, data){\n                data = data[data.length - 1];\n                (wrappedCallback || opts.callback)(data.err, data.result);\n            });\n        }\n\n        // If a callback is passed, run this as a controll flow\n        return opts.callback ? wrappedTask() : wrappedTask;\n    };\n\n    async.waterfall = function (tasks, callback) {\n        callback = _once(callback || noop);\n        if (!_isArray(tasks)) {\n            var err = new Error('First argument to waterfall must be an array of functions');\n            return callback(err);\n        }\n        if (!tasks.length) {\n            return callback();\n        }\n        function wrapIterator(iterator) {\n            return _restParam(function (err, args) {\n                if (err) {\n                    callback.apply(null, [err].concat(args));\n                }\n                else {\n                    var next = iterator.next();\n                    if (next) {\n                        args.push(wrapIterator(next));\n                    }\n                    else {\n                        args.push(callback);\n                    }\n                    ensureAsync(iterator).apply(null, args);\n                }\n            });\n        }\n        wrapIterator(async.iterator(tasks))();\n    };\n\n    function _parallel(eachfn, tasks, callback) {\n        callback = callback || noop;\n        var results = _isArrayLike(tasks) ? [] : {};\n\n        eachfn(tasks, function (task, key, callback) {\n            task(_restParam(function (err, args) {\n                if (args.length <= 1) {\n                    args = args[0];\n                }\n                results[key] = args;\n                callback(err);\n            }));\n        }, function (err) {\n            callback(err, results);\n        });\n    }\n\n    async.parallel = function (tasks, callback) {\n        _parallel(async.eachOf, tasks, callback);\n    };\n\n    async.parallelLimit = function(tasks, limit, callback) {\n        _parallel(_eachOfLimit(limit), tasks, callback);\n    };\n\n    async.series = function(tasks, callback) {\n        _parallel(async.eachOfSeries, tasks, callback);\n    };\n\n    async.iterator = function (tasks) {\n        function makeCallback(index) {\n            function fn() {\n                if (tasks.length) {\n                    tasks[index].apply(null, arguments);\n                }\n                return fn.next();\n            }\n            fn.next = function () {\n                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\n            };\n            return fn;\n        }\n        return makeCallback(0);\n    };\n\n    async.apply = _restParam(function (fn, args) {\n        return _restParam(function (callArgs) {\n            return fn.apply(\n                null, args.concat(callArgs)\n            );\n        });\n    });\n\n    function _concat(eachfn, arr, fn, callback) {\n        var result = [];\n        eachfn(arr, function (x, index, cb) {\n            fn(x, function (err, y) {\n                result = result.concat(y || []);\n                cb(err);\n            });\n        }, function (err) {\n            callback(err, result);\n        });\n    }\n    async.concat = doParallel(_concat);\n    async.concatSeries = doSeries(_concat);\n\n    async.whilst = function (test, iterator, callback) {\n        callback = callback || noop;\n        if (test()) {\n            var next = _restParam(function(err, args) {\n                if (err) {\n                    callback(err);\n                } else if (test.apply(this, args)) {\n                    iterator(next);\n                } else {\n                    callback.apply(null, [null].concat(args));\n                }\n            });\n            iterator(next);\n        } else {\n            callback(null);\n        }\n    };\n\n    async.doWhilst = function (iterator, test, callback) {\n        var calls = 0;\n        return async.whilst(function() {\n            return ++calls <= 1 || test.apply(this, arguments);\n        }, iterator, callback);\n    };\n\n    async.until = function (test, iterator, callback) {\n        return async.whilst(function() {\n            return !test.apply(this, arguments);\n        }, iterator, callback);\n    };\n\n    async.doUntil = function (iterator, test, callback) {\n        return async.doWhilst(iterator, function() {\n            return !test.apply(this, arguments);\n        }, callback);\n    };\n\n    async.during = function (test, iterator, callback) {\n        callback = callback || noop;\n\n        var next = _restParam(function(err, args) {\n            if (err) {\n                callback(err);\n            } else {\n                args.push(check);\n                test.apply(this, args);\n            }\n        });\n\n        var check = function(err, truth) {\n            if (err) {\n                callback(err);\n            } else if (truth) {\n                iterator(next);\n            } else {\n                callback(null);\n            }\n        };\n\n        test(check);\n    };\n\n    async.doDuring = function (iterator, test, callback) {\n        var calls = 0;\n        async.during(function(next) {\n            if (calls++ < 1) {\n                next(null, true);\n            } else {\n                test.apply(this, arguments);\n            }\n        }, iterator, callback);\n    };\n\n    function _queue(worker, concurrency, payload) {\n        if (concurrency == null) {\n            concurrency = 1;\n        }\n        else if(concurrency === 0) {\n            throw new Error('Concurrency must not be zero');\n        }\n        function _insert(q, data, pos, callback) {\n            if (callback != null && typeof callback !== \"function\") {\n                throw new Error(\"task callback must be a function\");\n            }\n            q.started = true;\n            if (!_isArray(data)) {\n                data = [data];\n            }\n            if(data.length === 0 && q.idle()) {\n                // call drain immediately if there are no tasks\n                return async.setImmediate(function() {\n                    q.drain();\n                });\n            }\n            _arrayEach(data, function(task) {\n                var item = {\n                    data: task,\n                    callback: callback || noop\n                };\n\n                if (pos) {\n                    q.tasks.unshift(item);\n                } else {\n                    q.tasks.push(item);\n                }\n\n                if (q.tasks.length === q.concurrency) {\n                    q.saturated();\n                }\n            });\n            async.setImmediate(q.process);\n        }\n        function _next(q, tasks) {\n            return function(){\n                workers -= 1;\n\n                var removed = false;\n                var args = arguments;\n                _arrayEach(tasks, function (task) {\n                    _arrayEach(workersList, function (worker, index) {\n                        if (worker === task && !removed) {\n                            workersList.splice(index, 1);\n                            removed = true;\n                        }\n                    });\n\n                    task.callback.apply(task, args);\n                });\n                if (q.tasks.length + workers === 0) {\n                    q.drain();\n                }\n                q.process();\n            };\n        }\n\n        var workers = 0;\n        var workersList = [];\n        var q = {\n            tasks: [],\n            concurrency: concurrency,\n            payload: payload,\n            saturated: noop,\n            empty: noop,\n            drain: noop,\n            started: false,\n            paused: false,\n            push: function (data, callback) {\n                _insert(q, data, false, callback);\n            },\n            kill: function () {\n                q.drain = noop;\n                q.tasks = [];\n            },\n            unshift: function (data, callback) {\n                _insert(q, data, true, callback);\n            },\n            process: function () {\n                while(!q.paused && workers < q.concurrency && q.tasks.length){\n\n                    var tasks = q.payload ?\n                        q.tasks.splice(0, q.payload) :\n                        q.tasks.splice(0, q.tasks.length);\n\n                    var data = _map(tasks, function (task) {\n                        return task.data;\n                    });\n\n                    if (q.tasks.length === 0) {\n                        q.empty();\n                    }\n                    workers += 1;\n                    workersList.push(tasks[0]);\n                    var cb = only_once(_next(q, tasks));\n                    worker(data, cb);\n                }\n            },\n            length: function () {\n                return q.tasks.length;\n            },\n            running: function () {\n                return workers;\n            },\n            workersList: function () {\n                return workersList;\n            },\n            idle: function() {\n                return q.tasks.length + workers === 0;\n            },\n            pause: function () {\n                q.paused = true;\n            },\n            resume: function () {\n                if (q.paused === false) { return; }\n                q.paused = false;\n                var resumeCount = Math.min(q.concurrency, q.tasks.length);\n                // Need to call q.process once per concurrent\n                // worker to preserve full concurrency after pause\n                for (var w = 1; w <= resumeCount; w++) {\n                    async.setImmediate(q.process);\n                }\n            }\n        };\n        return q;\n    }\n\n    async.queue = function (worker, concurrency) {\n        var q = _queue(function (items, cb) {\n            worker(items[0], cb);\n        }, concurrency, 1);\n\n        return q;\n    };\n\n    async.priorityQueue = function (worker, concurrency) {\n\n        function _compareTasks(a, b){\n            return a.priority - b.priority;\n        }\n\n        function _binarySearch(sequence, item, compare) {\n            var beg = -1,\n                end = sequence.length - 1;\n            while (beg < end) {\n                var mid = beg + ((end - beg + 1) >>> 1);\n                if (compare(item, sequence[mid]) >= 0) {\n                    beg = mid;\n                } else {\n                    end = mid - 1;\n                }\n            }\n            return beg;\n        }\n\n        function _insert(q, data, priority, callback) {\n            if (callback != null && typeof callback !== \"function\") {\n                throw new Error(\"task callback must be a function\");\n            }\n            q.started = true;\n            if (!_isArray(data)) {\n                data = [data];\n            }\n            if(data.length === 0) {\n                // call drain immediately if there are no tasks\n                return async.setImmediate(function() {\n                    q.drain();\n                });\n            }\n            _arrayEach(data, function(task) {\n                var item = {\n                    data: task,\n                    priority: priority,\n                    callback: typeof callback === 'function' ? callback : noop\n                };\n\n                q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);\n\n                if (q.tasks.length === q.concurrency) {\n                    q.saturated();\n                }\n                async.setImmediate(q.process);\n            });\n        }\n\n        // Start with a normal queue\n        var q = async.queue(worker, concurrency);\n\n        // Override push to accept second parameter representing priority\n        q.push = function (data, priority, callback) {\n            _insert(q, data, priority, callback);\n        };\n\n        // Remove unshift function\n        delete q.unshift;\n\n        return q;\n    };\n\n    async.cargo = function (worker, payload) {\n        return _queue(worker, 1, payload);\n    };\n\n    function _console_fn(name) {\n        return _restParam(function (fn, args) {\n            fn.apply(null, args.concat([_restParam(function (err, args) {\n                if (typeof console === 'object') {\n                    if (err) {\n                        if (console.error) {\n                            console.error(err);\n                        }\n                    }\n                    else if (console[name]) {\n                        _arrayEach(args, function (x) {\n                            console[name](x);\n                        });\n                    }\n                }\n            })]));\n        });\n    }\n    async.log = _console_fn('log');\n    async.dir = _console_fn('dir');\n    /*async.info = _console_fn('info');\n    async.warn = _console_fn('warn');\n    async.error = _console_fn('error');*/\n\n    async.memoize = function (fn, hasher) {\n        var memo = {};\n        var queues = {};\n        var has = Object.prototype.hasOwnProperty;\n        hasher = hasher || identity;\n        var memoized = _restParam(function memoized(args) {\n            var callback = args.pop();\n            var key = hasher.apply(null, args);\n            if (has.call(memo, key)) {   \n                async.setImmediate(function () {\n                    callback.apply(null, memo[key]);\n                });\n            }\n            else if (has.call(queues, key)) {\n                queues[key].push(callback);\n            }\n            else {\n                queues[key] = [callback];\n                fn.apply(null, args.concat([_restParam(function (args) {\n                    memo[key] = args;\n                    var q = queues[key];\n                    delete queues[key];\n                    for (var i = 0, l = q.length; i < l; i++) {\n                        q[i].apply(null, args);\n                    }\n                })]));\n            }\n        });\n        memoized.memo = memo;\n        memoized.unmemoized = fn;\n        return memoized;\n    };\n\n    async.unmemoize = function (fn) {\n        return function () {\n            return (fn.unmemoized || fn).apply(null, arguments);\n        };\n    };\n\n    function _times(mapper) {\n        return function (count, iterator, callback) {\n            mapper(_range(count), iterator, callback);\n        };\n    }\n\n    async.times = _times(async.map);\n    async.timesSeries = _times(async.mapSeries);\n    async.timesLimit = function (count, limit, iterator, callback) {\n        return async.mapLimit(_range(count), limit, iterator, callback);\n    };\n\n    async.seq = function (/* functions... */) {\n        var fns = arguments;\n        return _restParam(function (args) {\n            var that = this;\n\n            var callback = args[args.length - 1];\n            if (typeof callback == 'function') {\n                args.pop();\n            } else {\n                callback = noop;\n            }\n\n            async.reduce(fns, args, function (newargs, fn, cb) {\n                fn.apply(that, newargs.concat([_restParam(function (err, nextargs) {\n                    cb(err, nextargs);\n                })]));\n            },\n            function (err, results) {\n                callback.apply(that, [err].concat(results));\n            });\n        });\n    };\n\n    async.compose = function (/* functions... */) {\n        return async.seq.apply(null, Array.prototype.reverse.call(arguments));\n    };\n\n\n    function _applyEach(eachfn) {\n        return _restParam(function(fns, args) {\n            var go = _restParam(function(args) {\n                var that = this;\n                var callback = args.pop();\n                return eachfn(fns, function (fn, _, cb) {\n                    fn.apply(that, args.concat([cb]));\n                },\n                callback);\n            });\n            if (args.length) {\n                return go.apply(this, args);\n            }\n            else {\n                return go;\n            }\n        });\n    }\n\n    async.applyEach = _applyEach(async.eachOf);\n    async.applyEachSeries = _applyEach(async.eachOfSeries);\n\n\n    async.forever = function (fn, callback) {\n        var done = only_once(callback || noop);\n        var task = ensureAsync(fn);\n        function next(err) {\n            if (err) {\n                return done(err);\n            }\n            task(next);\n        }\n        next();\n    };\n\n    function ensureAsync(fn) {\n        return _restParam(function (args) {\n            var callback = args.pop();\n            args.push(function () {\n                var innerArgs = arguments;\n                if (sync) {\n                    async.setImmediate(function () {\n                        callback.apply(null, innerArgs);\n                    });\n                } else {\n                    callback.apply(null, innerArgs);\n                }\n            });\n            var sync = true;\n            fn.apply(this, args);\n            sync = false;\n        });\n    }\n\n    async.ensureAsync = ensureAsync;\n\n    async.constant = _restParam(function(values) {\n        var args = [null].concat(values);\n        return function (callback) {\n            return callback.apply(this, args);\n        };\n    });\n\n    async.wrapSync =\n    async.asyncify = function asyncify(func) {\n        return _restParam(function (args) {\n            var callback = args.pop();\n            var result;\n            try {\n                result = func.apply(this, args);\n            } catch (e) {\n                return callback(e);\n            }\n            // if result is Promise object\n            if (_isObject(result) && typeof result.then === \"function\") {\n                result.then(function(value) {\n                    callback(null, value);\n                })[\"catch\"](function(err) {\n                    callback(err.message ? err : new Error(err));\n                });\n            } else {\n                callback(null, result);\n            }\n        });\n    };\n\n    // Node.js\n    if (typeof module === 'object' && module.exports) {\n        module.exports = async;\n    }\n    // AMD / RequireJS\n    else if (typeof define === 'function' && define.amd) {\n        define([], function () {\n            return async;\n        });\n    }\n    // included directly via <script> tag\n    else {\n        root.async = async;\n    }\n\n}());\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"_process\":4}],4:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            currentQueue[queueIndex].run();\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}]},{},[2,1])(2)\n});\n//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJsaWIvYW5ndWxhci1hc3luYy1jaGFpbmFibGUuanMiLCJub2RlX21vZHVsZXMvYXN5bmMtY2hhaW5hYmxlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2FzeW5jL2xpYi9hc3luYy5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbDRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsImFuZ3VsYXIubW9kdWxlKCdhbmd1bGFyLWFzeW5jLWNoYWluYWJsZScsIFtdKVxuLnNlcnZpY2UoJyRhc3luYycsIGZ1bmN0aW9uKCkge1xuXHRpZiAoIXdpbmRvdy5hc3luY0NoYWluYWJsZSkgcmV0dXJuIGNvbnNvbGUuZXJyb3IoJ2FzeW5jQ2hhaW5hYmxlIG5vdCBsb2FkZWQhJyk7XG5cdHJldHVybiB3aW5kb3cuYXN5bmNDaGFpbmFibGU7XG59KTtcbiIsInZhciBhc3luYyA9IHJlcXVpcmUoJ2FzeW5jJyk7XG5cbi8qKlxuKiBFeGFtaW5lcyBhbiBhcmd1bWVudCBzdGFjayBhbmQgcmV0dXJucyBhbGwgcGFzc2VkIGFyZ3VtZW50cyBhcyBhIENTVlxuKiBlLmcuXG4qXHRmdW5jdGlvbiB0ZXN0ICgpIHsgZ2V0T3ZlcmxvYWQoYXJndW1lbnRzKSB9O1xuKlx0dGVzdCgnaGVsbG8nLCAnd29ybGQnKSAvLyAnc3RyaW5nLHN0cmluZydcbipcdHRlc3QoZnVuY3Rpb24oKSB7fSwgMSkgLy8gJ2Z1bmN0aW9uLG51bWJlcidcbipcdHRlc3QoJ2hlbGxvJywgMTIzLCB7Zm9vOiAnYmFyJ30sIFsnYmF6J10sIFt7cXV6OiAncXV6VmFsdWUnfSwge3F1dXo6ICdxdXV6VmFsdWUnfV0pIC8vICdzdHJpbmcsbnVtYmVyLG9iamVjdCxhcnJheSxjb2xsZWN0aW9uJ1xuKlxuKiBAcGFyYW0gb2JqZWN0IGFyZ3MgVGhlIHNwZWNpYWwgSmF2YVNjcmlwdCAnYXJndW1lbnRzJyBvYmplY3RcbiogQHJldHVybiBzdHJpbmcgQ1NWIG9mIGFsbCBwYXNzZWQgYXJndW1lbnRzXG4qL1xuZnVuY3Rpb24gZ2V0T3ZlcmxvYWQoYXJncykge1xuXHR2YXIgaSA9IDA7XG5cdHZhciBvdXQgPSBbXTtcblx0d2hpbGUoMSkge1xuXHRcdHZhciBhcmdUeXBlID0gdHlwZW9mIGFyZ3NbaV07XG5cdFx0aWYgKGFyZ1R5cGUgPT0gJ3VuZGVmaW5lZCcpIGJyZWFrO1xuXHRcdGlmIChhcmdUeXBlID09ICdvYmplY3QnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmdzW2ldKSA9PSAnW29iamVjdCBBcnJheV0nKSB7IC8vIFNwZWNpYWwgY2FzZSBmb3IgYXJyYXlzIGJlaW5nIGNsYXNzZWQgYXMgb2JqZWN0c1xuXHRcdFx0YXJnVHlwZSA9ICdhcnJheSc7XG5cdFx0XHRpZiAoYXJnc1tpXS5sZW5ndGggJiYgYXJnc1tpXS5ldmVyeShmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRcdHJldHVybiAodHlwZW9mIGl0ZW0gPT0gJ29iamVjdCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZW0pID09ICdbb2JqZWN0IE9iamVjdF0nKTtcblx0XHRcdH0pKVxuXHRcdFx0XHRhcmdUeXBlID0gJ2NvbGxlY3Rpb24nO1xuXHRcdH1cblx0XHRvdXQucHVzaChhcmdUeXBlKTtcblx0XHRpKys7XG5cdH1cblx0cmV0dXJuIG91dC50b1N0cmluZygpO1xufTtcblxuLy8gVXRpbGl0eSBmdW5jdGlvbnMge3t7XG4vKipcbiogUmV0dXJuIHRydWUgaWYgYSB2YXJpYWJsZSBpcyBhbiBhcnJheVxuKiBAcGFyYW0gbWl4ZWQgdGhpbmcgVGhlIHZhcmFibGUgdG8gZXhhbWluZVxuKiBAcmV0dXJuIGJvb2wgVHJ1ZSBpZiB0aGUgaXRlbSBpcyBhIGNsYXNzaWMgSlMgYXJyYXkgYW5kIG5vdCBhbiBvYmplY3RcbiovXG5mdW5jdGlvbiBpc0FycmF5KHRoaW5nKSB7XG5cdHJldHVybiAoXG5cdFx0dHlwZW9mIHRoaW5nID09ICdvYmplY3QnICYmXG5cdFx0T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaW5nKSA9PSAnW29iamVjdCBBcnJheV0nXG5cdCk7XG59XG5cblxuLyoqXG4qIFJldHVybiB0cnVlIGlmIGEgdmFyaWFibGUgaXMgYW4gb2JqZWN0XG4qIEBwYXJhbSBtaXhlZCB0aGluZyBUaGUgdmFyYWJsZSB0byBleGFtaW5lXG4qIEByZXR1cm4gYm9vbCBUcnVlIGlmIHRoZSBpdGVtIGlzIGEgY2xhc3NpYyBKUyBhcnJheSBhbmQgbm90IGFuIG9iamVjdFxuKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHRoaW5nKSB7XG5cdHJldHVybiAoXG5cdFx0dHlwZW9mIHRoaW5nID09ICdvYmplY3QnICYmXG5cdFx0T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaW5nKSAhPSAnW29iamVjdCBBcnJheV0nXG5cdCk7XG59XG4vLyB9fX1cblxuLy8gUGx1Z2luIGZ1bmN0aW9uYWxpdHkgLSB2aWEgYHVzZSgpYFxudmFyIF9wbHVnaW5zID0ge307XG5mdW5jdGlvbiB1c2UobW9kdWxlKSB7XG5cdG1vZHVsZS5jYWxsKHRoaXMpO1xuXHRyZXR1cm4gdGhpcztcbn07XG4vLyB9fX1cblxuLyoqXG4qIFF1ZXVlIHVwIGEgZnVuY3Rpb24ocykgdG8gZXhlY3V0ZSBpbiBzZXJpZXNcbiogQHBhcmFtIGFycmF5LG9iamVjdCxmdW5jdGlvbiBUaGUgZnVuY3Rpb24ocykgdG8gZXhlY3V0ZVxuKiBAcmV0dXJuIG9iamVjdCBUaGlzIGNoYWluYWJsZSBvYmplY3RcbiovXG5mdW5jdGlvbiBzZXJpZXMoKSB7XG5cdHZhciBjYWxsZWRBcyA9IGdldE92ZXJsb2FkKGFyZ3VtZW50cyk7XG5cdHN3aXRjaChjYWxsZWRBcykge1xuXHRcdGNhc2UgJyc6XG5cdFx0XHQvLyBQYXNzXG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdmdW5jdGlvbic6IC8vIEZvcm06IHNlcmllcyhmdW5jKVxuXHRcdFx0dGhpcy5fc3RydWN0LnB1c2goeyB0eXBlOiAnc2VyaWVzQXJyYXknLCBwYXlsb2FkOiBbYXJndW1lbnRzWzBdXSB9KTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgICdzdHJpbmcsZnVuY3Rpb24nOiAvLyBGb3JtOiBzZXJpZXMoU3RyaW5nIDxpZD4sIGZ1bmMpXG5cdFx0XHR2YXIgcGF5bG9hZCA9IHt9O1xuXHRcdFx0cGF5bG9hZFthcmd1bWVudHNbMF1dID0gYXJndW1lbnRzWzFdO1xuXHRcdFx0dGhpcy5fc3RydWN0LnB1c2goeyB0eXBlOiAnc2VyaWVzT2JqZWN0JywgcGF5bG9hZDogcGF5bG9hZH0pO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnYXJyYXknOiAvLyBGb3JtOiBzZXJpZXMoQXJyYXkgPGZ1bmNzPilcblx0XHRcdHRoaXMuX3N0cnVjdC5wdXNoKHsgdHlwZTogJ3Nlcmllc0FycmF5JywgcGF5bG9hZDogYXJndW1lbnRzWzBdIH0pO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnb2JqZWN0JzogLy8gRm9ybTogc2VyaWVzKE9iamVjdCA8ZnVuY3M+KVxuXHRcdFx0dGhpcy5fc3RydWN0LnB1c2goeyB0eXBlOiAnc2VyaWVzT2JqZWN0JywgcGF5bG9hZDogYXJndW1lbnRzWzBdIH0pO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnY29sbGVjdGlvbic6IC8vIEZvcm06IHNlcmllcyhDb2xsZWN0aW9uIDxmdW5jcz4pXG5cdFx0XHR0aGlzLl9zdHJ1Y3QucHVzaCh7IHR5cGU6ICdzZXJpZXNDb2xsZWN0aW9uJywgcGF5bG9hZDogYXJndW1lbnRzWzBdIH0pO1xuXHRcdFx0YnJlYWs7XG5cblx0XHQvLyBBc3luYyBsaWJyYXJ5IGNvbXBhdGliaWxpdHkge3t7XG5cdFx0Y2FzZSAnYXJyYXksZnVuY3Rpb24nOlxuXHRcdFx0dGhpcy5fc3RydWN0LnB1c2goeyB0eXBlOiAnc2VyaWVzQXJyYXknLCBwYXlsb2FkOiBhcmd1bWVudHNbMF0gfSk7XG5cdFx0XHR0aGlzLmVuZChhcmd1bWVudHNbMV0pO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnb2JqZWN0LGZ1bmN0aW9uJzpcblx0XHRcdHRoaXMuX3N0cnVjdC5wdXNoKHsgdHlwZTogJ3Nlcmllc09iamVjdCcsIHBheWxvYWQ6IGFyZ3VtZW50c1swXSB9KTtcblx0XHRcdHRoaXMuZW5kKGFyZ3VtZW50c1sxXSk7XG5cdFx0XHRicmVhaztcblx0XHQvLyB9fX1cblx0XHRkZWZhdWx0OlxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGNhbGwgc3R5bGUgZm9yIC5zZXJpZXMoKTogJyArIGNhbGxlZEFzKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbiogUXVldWUgdXAgYSBmdW5jdGlvbihzKSB0byBleGVjdXRlIGluIHBhcmFsbGVsXG4qIEBwYXJhbSBhcnJheSxvYmplY3QsZnVuY3Rpb24gVGhlIGZ1bmN0aW9uKHMpIHRvIGV4ZWN1dGVcbiogQHJldHVybiBvYmplY3QgVGhpcyBjaGFpbmFibGUgb2JqZWN0XG4qL1xuZnVuY3Rpb24gcGFyYWxsZWwoKSB7XG5cdHZhciBjYWxsZWRBcyA9IGdldE92ZXJsb2FkKGFyZ3VtZW50cylcblx0c3dpdGNoIChjYWxsZWRBcykge1xuXHRcdGNhc2UgJyc6XG5cdFx0XHQvLyBQYXNzXG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdmdW5jdGlvbic6IC8vIEZvcm06IHBhcmFsbGVsKGZ1bmMpXG5cdFx0XHR0aGlzLl9zdHJ1Y3QucHVzaCh7IHR5cGU6ICdwYXJhbGxlbEFycmF5JywgcGF5bG9hZDogW2FyZ3VtZW50c1swXV0gfSk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdzdHJpbmcsZnVuY3Rpb24nOiAvLyBGb3JtOiBwYXJhbGxlbChTdHJpbmcgPGlkPiwgZnVuYylcblx0XHRcdHZhciBwYXlsb2FkID0ge307XG5cdFx0XHRwYXlsb2FkW2FyZ3VtZW50c1swXV0gPSBhcmd1bWVudHNbMV07XG5cdFx0XHR0aGlzLl9zdHJ1Y3QucHVzaCh7IHR5cGU6ICdwYXJhbGxlbEFycmF5JywgcGF5bG9hZDogcGF5bG9hZCB9KTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ2FycmF5JzogLy8gRm9ybTogcGFyYWxsZWwoQXJyYXkgPGZ1bmNzPilcblx0XHRcdHRoaXMuX3N0cnVjdC5wdXNoKHsgdHlwZTogJ3BhcmFsbGVsQXJyYXknLCBwYXlsb2FkOiBhcmd1bWVudHNbMF0gfSk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdvYmplY3QnOiAvLyBGb3JtOiBwYXJhbGxlbChPYmplY3QgPGZ1bmNzPilcblx0XHRcdHRoaXMuX3N0cnVjdC5wdXNoKHsgdHlwZTogJ3BhcmFsbGVsT2JqZWN0JywgcGF5bG9hZDogYXJndW1lbnRzWzBdIH0pO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnY29sbGVjdGlvbic6IC8vIEZvcm06IHBhcmFsbGVsKENvbGxlY3Rpb24gPGZ1bmNzPilcblx0XHRcdHRoaXMuX3N0cnVjdC5wdXNoKHsgdHlwZTogJ3BhcmFsbGVsQ29sbGVjdGlvbicsIHBheWxvYWQ6IGFyZ3VtZW50c1swXSB9KTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Ly8gQXN5bmMgbGlicmFyeSBjb21wYXRpYmlsaXR5IHt7e1xuXHRcdGNhc2UgJ2FycmF5LGZ1bmN0aW9uJzpcblx0XHRcdHRoaXMuX3N0cnVjdC5wdXNoKHsgdHlwZTogJ3BhcmFsbGVsQXJyYXknLCBwYXlsb2FkOiBhcmd1bWVudHNbMF0gfSk7XG5cdFx0XHR0aGlzLmVuZChhcmd1bWVudHNbMV0pO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnb2JqZWN0LGZ1bmN0aW9uJzpcblx0XHRcdHRoaXMuX3N0cnVjdC5wdXNoKHsgdHlwZTogJ3BhcmFsbGVsT2JqZWN0JywgcGF5bG9hZDogYXJndW1lbnRzWzBdIH0pO1xuXHRcdFx0dGhpcy5lbmQoYXJndW1lbnRzWzFdKTtcblx0XHRcdGJyZWFrO1xuXHRcdC8vIH19fVxuXHRcdGRlZmF1bHQ6XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gY2FsbCBzdHlsZSBmb3IgLnBhcmFsbGVsKCk6ICcgKyBjYWxsZWRBcyk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuLyoqXG4qIFJ1biBhbiBhcnJheS9vYmplY3QvY29sbGVjdGlvbiB0aG91Z2ggYSBmdW5jdGlvblxuKiBUaGlzIGlzIHNpbWlsYXIgdG8gdGhlIGFzeW5jIG5hdGl2ZSAuZWFjaCgpIGZ1bmN0aW9uIGJ1dCBjaGFpbmFibGVcbiovXG5mdW5jdGlvbiBmb3JFYWNoKCkge1xuXHR2YXIgY2FsbGVkQXMgPSBnZXRPdmVybG9hZChhcmd1bWVudHMpXG5cdHN3aXRjaCAoY2FsbGVkQXMpIHtcblx0XHRjYXNlICcnOlxuXHRcdFx0Ly8gUGFzc1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnY29sbGVjdGlvbixmdW5jdGlvbic6IC8vIEZvcm06IGZvckVhY2goQ29sbGVjdGlvbiBmdW5jKVxuXHRcdGNhc2UgJ2FycmF5LGZ1bmN0aW9uJzogLy8gRm9ybTogZm9yRWFjaChBcnJheSwgZnVuYylcblx0XHRcdHRoaXMuX3N0cnVjdC5wdXNoKHsgdHlwZTogJ2ZvckVhY2hBcnJheScsIHBheWxvYWQ6IGFyZ3VtZW50c1swXSwgY2FsbGJhY2s6IGFyZ3VtZW50c1sxXSB9KTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ29iamVjdCxmdW5jdGlvbic6IC8vIEZvcm06IGZvckVhY2goT2JqZWN0LCBmdW5jKVxuXHRcdFx0dGhpcy5fc3RydWN0LnB1c2goeyB0eXBlOiAnZm9yRWFjaE9iamVjdCcsIHBheWxvYWQ6IGFyZ3VtZW50c1swXSwgY2FsbGJhY2s6IGFyZ3VtZW50c1sxXSB9KTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ3N0cmluZyxmdW5jdGlvbic6IC8vIEZvcm06IGZvckVhY2goU3RyaW5nIDxzZXQgbG9va3VwPiwgZnVuYylcblx0XHRcdHRoaXMuX3N0cnVjdC5wdXNoKHsgdHlwZTogJ2ZvckVhY2hMYXRlQm91bmQnLCBwYXlsb2FkOiBhcmd1bWVudHNbMF0sIGNhbGxiYWNrOiBhcmd1bWVudHNbMV0gfSk7XG5cdFx0XHRicmVhaztcblx0XHRkZWZhdWx0OlxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGNhbGwgc3R5bGUgZm9yIC5mb3JFYWNoKCk6ICcgKyBjYWxsZWRBcyk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn1cblxuXG4vLyBEZWZlciBmdW5jdGlvbmFsaXR5IC0gSGVyZSBiZSBkcmFnb25zISB7e3tcbi8qKlxuKiBDb2xsZWN0aW9uIG9mIGl0ZW1zIHRoYXQgaGF2ZSBiZWVuIGRlZmVycmVkXG4qIEB0eXBlIGNvbGxlY3Rpb24ge3BheWxvYWQ6IGZ1bmN0aW9uLCBpZDogbnVsbHxTdHJpbmcsIHByZXJlcTogW2RlcDEsIGRlcDIuLi5dfVxuKiBAYWNjZXNzIHByaXZhdGVcbiovXG5mdW5jdGlvbiBkZWZlckFkZChpZCwgdGFzaywgcGFyZW50Q2hhaW4pIHtcblx0dmFyIHNlbGYgPSB0aGlzO1xuXHRwYXJlbnRDaGFpbi53YWl0aW5nT24gPSAocGFyZW50Q2hhaW4ud2FpdGluZ09uIHx8IDApICsgMTtcblxuXHRpZiAoISBwYXJlbnRDaGFpbi53YWl0aW5nT25JZHMpXG5cdFx0cGFyZW50Q2hhaW4ud2FpdGluZ09uSWRzID0gW107XG5cdHBhcmVudENoYWluLndhaXRpbmdPbklkcy5wdXNoKGlkKTtcblxuXHRzZWxmLl9kZWZlcnJlZC5wdXNoKHtcblx0XHRpZDogaWQgfHwgbnVsbCxcblx0XHRwcmVyZXE6IHBhcmVudENoYWluLnByZXJlcSB8fCBbXSxcblx0XHRwYXlsb2FkOiBmdW5jdGlvbihuZXh0KSB7XG5cdFx0XHRzZWxmLl9jb250ZXh0Ll9pZCA9IGlkO1xuXHRcdFx0dGFzay5jYWxsKHNlbGYuX29wdGlvbnMuY29udGV4dCwgZnVuY3Rpb24oZXJyLCB2YWx1ZSkge1xuXHRcdFx0XHRpZiAoaWQpXG5cdFx0XHRcdFx0c2VsZi5fY29udGV4dFtpZF0gPSB2YWx1ZTtcblx0XHRcdFx0c2VsZi5fZGVmZXJyZWRSdW5uaW5nLS07XG5cdFx0XHRcdGlmICgtLXBhcmVudENoYWluLndhaXRpbmdPbiA9PSAwKSB7XG5cdFx0XHRcdFx0cGFyZW50Q2hhaW4uY29tcGxldGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRpZiAoc2VsZi5fc3RydWN0Lmxlbmd0aCAmJiBzZWxmLl9zdHJ1Y3Rbc2VsZi5fc3RydWN0UG9pbnRlcl0udHlwZSA9PSAnYXdhaXQnKVxuXHRcdFx0XHRcdFx0c2VsZi5fZXhlY3V0ZShlcnIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYuX2V4ZWN1dGUoZXJyKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fSk7XG59O1xuXG5cbmZ1bmN0aW9uIF9kZWZlckNoZWNrKCkge1xuXHR2YXIgc2VsZiA9IHRoaXM7XG5cdGlmIChzZWxmLl9vcHRpb25zLmxpbWl0ICYmIHNlbGYuX2RlZmVycmVkUnVubmluZyA+PSBzZWxmLl9vcHRpb25zLmxpbWl0KSByZXR1cm47IC8vIEFscmVhZHkgb3ZlciBsaW1pdFxuXHRzZWxmLl9kZWZlcnJlZCA9IHNlbGYuX2RlZmVycmVkLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG5cdFx0aWYgKHNlbGYuX29wdGlvbnMubGltaXQgJiYgc2VsZi5fZGVmZXJyZWRSdW5uaW5nID49IHNlbGYuX29wdGlvbnMubGltaXQpIHtcblx0XHRcdHJldHVybiB0cnVlOyAvLyBBbHJlYWR5IG92ZXIgbGltaXQgLSBhbGwgc3Vic2VxZW50IGl0ZW1zIHNob3VsZCBiZSBsZWZ0IGluIHBsYWNlXG5cdFx0fVxuXHRcdGlmIChcblx0XHRcdGl0ZW0ucHJlcmVxLmxlbmd0aCA9PSAwIHx8IC8vIE5vIHByZS1yZXFzIC0gY2FuIGV4ZWN1dGUgbm93XG5cdFx0XHRpdGVtLnByZXJlcS5ldmVyeShmdW5jdGlvbihkZXApIHsgLy8gQWxsIHByZS1yZXFzIGFyZSBzYXRpc2ZpZWRcblx0XHRcdFx0cmV0dXJuIHNlbGYuX2NvbnRleHQuaGFzT3duUHJvcGVydHkoZGVwKTtcblx0XHRcdH0pXG5cdFx0KSB7IFxuXHRcdFx0c2VsZi5fZGVmZXJyZWRSdW5uaW5nKys7XG5cdFx0XHRzZXRUaW1lb3V0KGl0ZW0ucGF5bG9hZCk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSBlbHNlIHsgLy8gQ2FuJ3QgZG8gYW55dGhpbmcgd2l0aCBzZWxmIHJpZ2h0IG5vd1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9KTtcbn07XG4vLyB9fX1cblxuXG4vKipcbiogUXVldWUgdXAgYSBmdW5jdGlvbihzKSB0byBleGVjdXRlIGFzIGRlZmVycmVkIC0gaS5lLiBkb250IHN0b3AgdG8gd2FpdCBmb3IgaXRcbiogQHBhcmFtIGFycmF5LG9iamVjdCxmdW5jdGlvbiBUaGUgZnVuY3Rpb24ocykgdG8gZXhlY3V0ZSBhcyBhIGRlZmVyXG4qIEByZXR1cm4gb2JqZWN0IFRoaXMgY2hhaW5hYmxlIG9iamVjdFxuKi9cbmZ1bmN0aW9uIGRlZmVyKCkge1xuXHR2YXIgY2FsbGVkQXMgPSBnZXRPdmVybG9hZChhcmd1bWVudHMpO1xuXHRzd2l0Y2ggKGNhbGxlZEFzKSB7XG5cdFx0Y2FzZSAnJzpcblx0XHRcdC8vIFBhc3Ncblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ2Z1bmN0aW9uJzogLy8gRm9ybTogZGVmZXIoZnVuYylcblx0XHRcdHRoaXMuX3N0cnVjdC5wdXNoKHsgdHlwZTogJ2RlZmVyQXJyYXknLCBwYXlsb2FkOiBbYXJndW1lbnRzWzBdXSB9KTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ3N0cmluZyxmdW5jdGlvbic6IC8vIEZvcm06IGRlZmVyKFN0cmluZyA8aWQ+LCBmdW5jKVxuXHRcdFx0dmFyIHBheWxvYWQgPSB7fTtcblx0XHRcdHBheWxvYWRbYXJndW1lbnRzWzBdXSA9IGFyZ3VtZW50c1sxXTtcblx0XHRcdHRoaXMuX3N0cnVjdC5wdXNoKHsgdHlwZTogJ2RlZmVyT2JqZWN0JywgcGF5bG9hZDogcGF5bG9hZCB9KTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ2FycmF5JzogLy8gRm9ybTogZGVmZXIoQXJyYXkgPGZ1bmNzPilcblx0XHRcdHRoaXMuX3N0cnVjdC5wdXNoKHsgdHlwZTogJ2RlZmVyQXJyYXknLCBwYXlsb2FkOiBhcmd1bWVudHNbMF0gfSk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdvYmplY3QnOiAvLyBGb3JtOiBkZWZlcihPYmplY3QgPGZ1bmNzPilcblx0XHRcdHRoaXMuX3N0cnVjdC5wdXNoKHsgdHlwZTogJ2RlZmVyT2JqZWN0JywgcGF5bG9hZDogYXJndW1lbnRzWzBdIH0pO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnY29sbGVjdGlvbic6IC8vIEZvcm0gZGVmZXIoQ29sbGVjdGlvbiA8ZnVuY3M+KVxuXHRcdFx0dGhpcy5fc3RydWN0LnB1c2goeyB0eXBlOiAnZGVmZXJDb2xsZWN0aW9uJywgcGF5bG9hZDogYXJndW1lbnRzWzBdIH0pO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnYXJyYXksZnVuY3Rpb24nOiAvLyBGb3JtOiBkZWZlcihBcnJheSA8cHJlcmVxcz4sIGZ1bmMpXG5cdFx0XHR0aGlzLl9zdHJ1Y3QucHVzaCh7IHR5cGU6ICdkZWZlckFycmF5JywgcHJlcmVxOiBhcmd1bWVudHNbMF0sIHBheWxvYWQ6IFthcmd1bWVudHNbMV1dIH0pO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnc3RyaW5nLHN0cmluZyxmdW5jdGlvbic6IC8vIEZvcm06IGRlZmVyKFN0cmluZyA8cHJlcmVxPiwgU3RyaW5nIDxuYW1lPiwgZnVuYylcblx0XHRcdHZhciBwYXlsb2FkID0ge307XG5cdFx0XHRwYXlsb2FkW2FyZ3VtZW50c1sxXV0gPSBhcmd1bWVudHNbMl07XG5cdFx0XHR0aGlzLl9zdHJ1Y3QucHVzaCh7IHR5cGU6ICdkZWZlck9iamVjdCcsIHByZXJlcTogW2FyZ3VtZW50c1swXV0sIHBheWxvYWQ6IHBheWxvYWQgfSk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdhcnJheSxzdHJpbmcsZnVuY3Rpb24nOiAvL0Zvcm06IGRlZmVyKEFycmF5IDxwcmVyZXFzPiwgU3RyaW5nIDxpZD4sIGZ1bmMpXG5cdFx0XHR2YXIgcGF5bG9hZCA9IHt9O1xuXHRcdFx0cGF5bG9hZFthcmd1bWVudHNbMV1dID0gYXJndW1lbnRzWzJdO1xuXHRcdFx0dGhpcy5fc3RydWN0LnB1c2goeyB0eXBlOiAnZGVmZXJPYmplY3QnLCBwcmVyZXE6IGFyZ3VtZW50c1swXSwgcGF5bG9hZDogcGF5bG9hZCB9KTtcblx0XHRcdGJyZWFrO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gY2FsbCBzdHlsZSBmb3IgLmRlZmVyKCk6JyArIGNhbGxlZEFzKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbiogUXVldWUgdXAgYW4gYXdhaXQgcG9pbnRcbiogVGhpcyBzdG9wcyB0aGUgZXhlY3V0aW9uIHF1ZXVlIHVudGlsIGl0cyBzYXRpc2ZpZWQgdGhhdCBkZXBlbmRlbmNpZXMgaGF2ZSBiZWVuIHJlc29sdmVkXG4qIEBwYXJhbSBhcnJheSwuLi4gVGhlIGRlcGVuZGVuY2llcyB0byBjaGVjayByZXNvbHV0aW9uIG9mLiBJZiBvbWl0dGVkIGFsbCBhcmUgY2hlY2tlZFxuKiBAcmV0dXJuIG9iamVjdCBUaGlzIGNoYWluYWJsZSBvYmplY3RcbiovXG5mdW5jdGlvbiBhd2FpdCgpIHtcblx0dmFyIHBheWxvYWQgPSBbXTtcblxuXHQvLyBTbHVycCBhbGwgYXJncyBpbnRvIHBheWxvYWQge3t7XG5cdHZhciBhcmdzID0gYXJndW1lbnRzO1xuXHRnZXRPdmVybG9hZChhcmd1bWVudHMpLnNwbGl0KCcsJykuZm9yRWFjaChmdW5jdGlvbih0eXBlLCBvZmZzZXQpIHtcblx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdGNhc2UgJyc6IC8vIEJsYW5rIGFyZ3VtZW50cyAtIGRvIG5vdGhpbmdcblx0XHRcdFx0Ly8gUGFzc1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3N0cmluZyc6XG5cdFx0XHRcdHBheWxvYWQucHVzaChhcmdzW29mZnNldF0pO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2FycmF5Jzpcblx0XHRcdFx0cGF5bG9hZC5jb25jYXQoYXJnc1tvZmZzZXRdKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gYXJndW1lbnQgdHlwZSBwYXNzZWQgdG8gLmF3YWl0KCk6ICcgKyB0eXBlKTtcblx0XHR9XG5cdH0pO1xuXHQvLyB9fX1cblxuXHR0aGlzLl9zdHJ1Y3QucHVzaCh7IHR5cGU6ICdhd2FpdCcsIHBheWxvYWQ6IHBheWxvYWQgfSk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuKiBRdWV1ZSB1cCBhIGxpbWl0IHNldHRlclxuKiBAcGFyYW0gaW50fG51bGx8ZmFsc2UgRWl0aGVyIHRoZSBudW1iZXIgb2YgZGVmZXIgcHJvY2Vzc2VzIHRoYXQgYXJlIGFsbG93ZWQgdG8gZXhlY3V0ZSBzaW11bHRhbmlvdXNseSBvciBmYWxzeSB2YWx1ZXMgdG8gZGlzYWJsZVxuKiBAcmV0dXJuIG9iamVjdCBUaGlzIGNoYWluYWJsZSBvYmplY3RcbiovXG5mdW5jdGlvbiBzZXRMaW1pdChzZXRMaW1pdCkge1xuXHR0aGlzLl9zdHJ1Y3QucHVzaCh7IHR5cGU6ICdsaW1pdCcsIHBheWxvYWQ6IHNldExpbWl0IH0pO1xuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuLyoqXG4qIFF1ZXVlIHVwIGEgY29udGV4dCBzZXR0ZXJcbiogQHBhcmFtIG9iamVjdCBuZXdDb250ZXh0IFRoZSBuZXcgY29udGV4dCB0byBwYXNzIHRvIGFsbCBzdWJzZXF1ZW50IGZ1bmN0aW9ucyB2aWEgYHRoaXNgXG4qIEByZXR1cm4gb2JqZWN0IFRoaXMgY2hhaW5hYmxlIG9iamVjdFxuKi9cbmZ1bmN0aW9uIHNldENvbnRleHQobmV3Q29udGV4dCkge1xuXHR0aGlzLl9zdHJ1Y3QucHVzaCh7IHR5cGU6ICdjb250ZXh0JywgcGF5bG9hZDogbmV3Q29udGV4dCB9KTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuKiBRdWV1ZSB1cCBhIHZhcmFibGUgc2V0dGVyIChpLmUuIHNldCBhIGhhc2ggb2YgdmFyaWFibGVzIGluIGNvbnRleHQpXG4qIEBwYXJhbSBzdHJpbmcgVGhlIG5hbWVkIGtleSB0byBzZXRcbiogQHBhcmFtIG1peGVkIFRoZSB2YWx1ZSB0byBzZXRcbiogQHJldHVybiBvYmplY3QgVGhpcyBjaGFpbmFibGUgb2JqZWN0XG4qL1xuZnVuY3Rpb24gc2V0KCkge1xuXHR2YXIgY2FsbGVkQXMgPSBnZXRPdmVybG9hZChhcmd1bWVudHMpO1xuXHRzd2l0Y2goY2FsbGVkQXMpIHtcblx0XHRjYXNlICcnOlxuXHRcdFx0Ly8gUGFzc1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnc3RyaW5nLHN0cmluZyc6IC8vIEZvcm06IHNldChTdHJpbmcgPGtleT4sIFN0cmluZyA8dmFsdWU+KVxuXHRcdGNhc2UgJ3N0cmluZyxudW1iZXInOiAvLyBGb3JtOiBzZXQoU3RyaW5nIDxrZXk+LCBOdW1iZXIgPHZhbHVlPilcblx0XHRjYXNlICdzdHJpbmcsYm9vbGVhbic6IC8vIEZvcm06IHNldChTdHJpbmcgPGtleT4sIEJvb2xlYW4gPHZhbHVlPilcblx0XHRjYXNlICdzdHJpbmcsYXJyYXknOiAvLyBGb3JtOiBzZXQoU3RyaW5nIDxrZXk+LCBBcnJheSA8dmFsdWU+KVxuXHRcdGNhc2UgJ3N0cmluZyxjb2xsZWN0aW9uJzogLy8gRm9ybTogc2V0KFN0cmluZyA8a2V5PiwgQ29sbGVjdGlvbiA8dmFsdWU+KVxuXHRcdGNhc2UgJ3N0cmluZyxvYmplY3QnOiAvLyBGb3JtOiBzZXQoU3RyaW5nIDxrZXk+LCBPYmplY3QgPHZhbHVlPilcblx0XHRcdHZhciBwYXlsb2FkID0ge307XG5cdFx0XHRwYXlsb2FkW2FyZ3VtZW50c1swXV0gPSBhcmd1bWVudHNbMV07XG5cdFx0XHR0aGlzLl9zdHJ1Y3QucHVzaCh7IHR5cGU6ICdzZXQnLCBwYXlsb2FkOiBwYXlsb2FkIH0pO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnb2JqZWN0JzogLy8gRm9ybTogc2V0KE9iamVjdClcblx0XHRcdHRoaXMuX3N0cnVjdC5wdXNoKHsgdHlwZTogJ3NldCcsIHBheWxvYWQ6IGFyZ3VtZW50c1swXSB9KTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ2Z1bmN0aW9uJzogLy8gRm9ybTogc2V0KGZ1bmMpIC0+IHNlcmllcyhmdW5jKVxuXHRcdFx0dGhpcy5fc3RydWN0LnB1c2goeyB0eXBlOiAnc2VyaWVzQXJyYXknLCBwYXlsb2FkOiBbYXJndW1lbnRzWzBdXSB9KTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgICdzdHJpbmcsZnVuY3Rpb24nOiAvLyBGb3JtOiBzZXQoU3RyaW5nLCBmdW5jKSAtPiBzZXJpZXMoU3RyaW5nIDxpZD4sIGZ1bmMpXG5cdFx0XHR2YXIgcGF5bG9hZCA9IHt9O1xuXHRcdFx0cGF5bG9hZFthcmd1bWVudHNbMF1dID0gYXJndW1lbnRzWzFdO1xuXHRcdFx0dGhpcy5fc3RydWN0LnB1c2goeyB0eXBlOiAnc2VyaWVzT2JqZWN0JywgcGF5bG9hZDogcGF5bG9hZH0pO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnc3RyaW5nJzogLy8gU2V0IHRvIHVuZGVmaW5lZFxuXHRcdFx0dGhpcy5fc2V0UmF3KGFyZ3VtZW50c1swXSwgdW5kZWZpbmVkKTtcblx0XHRcdGJyZWFrO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gY2FsbCBzdHlsZSBmb3IgLnNldCgpOicgKyBjYWxsZWRBcyk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuLyoqXG4qIFNldCBhIGNvbnRleHQgaXRlbXMgdmFsdWVcbiogTm90IHRvIGJlIGNvbmZ1c2VkIHdpdGggYHNldCgpYCB3aGljaCBpcyB0aGUgY2hhaW5hYmxlIGV4dGVybmFsIHZpc2libGUgdmVyc2lvbiBvZiB0aGlzXG4qIFVubGlrZSBgc2V0KClgIHRoaXMgZnVuY3Rpb24gc2V0cyBhbiBpdGVtIG9mIF9jb250ZXh0IGltbWVkaWF0ZWx5XG4qIEBhY2Nlc3MgcHJpdmF0ZVxuKiBAc2VlIF9zZXRSYXcoKVxuKi9cbmZ1bmN0aW9uIF9zZXQoKSB7XG5cdHZhciBjYWxsZWRBcyA9IGdldE92ZXJsb2FkKGFyZ3VtZW50cyk7XG5cdHN3aXRjaChjYWxsZWRBcykge1xuXHRcdGNhc2UgJyc6XG5cdFx0XHQvLyBQYXNzXG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdzdHJpbmcsc3RyaW5nJzogLy8gRm9ybTogc2V0KFN0cmluZyA8a2V5PiwgU3RyaW5nIDx2YWx1ZT4pXG5cdFx0Y2FzZSAnc3RyaW5nLG51bWJlcic6IC8vIEZvcm06IHNldChTdHJpbmcgPGtleT4sIE51bWJlciA8dmFsdWU+KVxuXHRcdGNhc2UgJ3N0cmluZyxib29sZWFuJzogLy8gRm9ybTogc2V0KFN0cmluZyA8a2V5PiwgQm9vbGVhbiA8dmFsdWU+KVxuXHRcdGNhc2UgJ3N0cmluZyxhcnJheSc6IC8vIEZvcm06IHNldChTdHJpbmcgPGtleT4sIEFycmF5IDx2YWx1ZT4pXG5cdFx0Y2FzZSAnc3RyaW5nLGNvbGxlY3Rpb24nOiAvLyBGb3JtOiBzZXQoU3RyaW5nIDxrZXk+LCBDb2xsZWN0aW9uIDx2YWx1ZT4pXG5cdFx0Y2FzZSAnc3RyaW5nLG9iamVjdCc6IC8vIEZvcm06IHNldChTdHJpbmcgPGtleT4sIE9iamVjdCA8dmFsdWU+KVxuXHRcdFx0dGhpcy5fc2V0UmF3KGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ29iamVjdCc6IC8vIEZvcm06IHNldChPYmplY3QpXG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gYXJndW1lbnRzWzBdKVxuXHRcdFx0XHR0aGlzLl9zZXRSYXcoa2V5LCBhcmd1bWVudHNbMF1ba2V5XSk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICAnc3RyaW5nLGZ1bmN0aW9uJzogLy8gRm9ybTogc2V0KFN0cmluZywgZnVuYykgLT4gc2VyaWVzKFN0cmluZyA8aWQ+LCBmdW5jKVxuXHRcdFx0dGhpcy5fc2V0UmF3KGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdLmNhbGwodGhpcykpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnZnVuY3Rpb24nOiAvLyBGb3JtOiBfc2V0KGZ1bmMpIC8vIEV4cGVjdCBmdW5jIHRvIHJldHVybiBzb21ldGhpbmcgd2hpY2ggaXMgdGhlbiBwcm9jZXNzZWQgdG8gX3NldFxuXHRcdFx0dGhpcy5fc2V0KGFyZ3VtZW50c1sxXS5jYWxsKHRoaXMpKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ3N0cmluZyc6IC8vIFNldCB0byB1bmRlZmluZWRcblx0XHRcdHRoaXMuX3NldFJhdyhhcmd1bWVudHNbMF0sIHVuZGVmaW5lZCk7XG5cdFx0XHRicmVhaztcblx0XHRkZWZhdWx0OlxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGNhbGwgc3R5bGUgZm9yIC5zZXQoKTonICsgY2FsbGVkQXMpO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59XG5cblxuLyoqXG4qIEFjdHVhbCByYXcgdmFsdWUgc2V0dGVyXG4qIFRoaXMgZnVuY3Rpb24gaXMgdGhlIGludGVybmFsIHZlcnNpb24gb2YgX3NldCB3aGljaCB0YWtlcyBleGFjdGx5IHR3byB2YWx1ZXMsIHRoZSBrZXkgYW5kIHRoZSB2YWx1ZSB0byBzZXRcbiogT3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpZiBzb21lIGFsdGVybmF0aXZlIF9jb250ZXh0IHBsYXRmb3JtIGlzIHJlcXVpcmVkXG4qIEBwYXJhbSBzdHJpbmcga2V5IFRoZSBrZXkgd2l0aGluIF9jb250ZXh0IHRvIHNldCB0aGUgdmFsdWUgb2ZcbiogQHBhcmFtIG1peGVkIHZhbHVlIFRoZSB2YWx1ZSB3aXRoaW4gX2NvbnRleHRba2V5XSB0byBzZXQgdGhlIHZhbHVlIG9mXG4qIEBhY2Nlc3MgcHJpdmF0ZVxuKi9cbmZ1bmN0aW9uIF9zZXRSYXcoa2V5LCB2YWx1ZSkge1xuXHR0aGlzLl9jb250ZXh0W2tleV0gPSB2YWx1ZTtcblx0cmV0dXJuIHRoaXM7XG59XG5cblxuLyoqXG4qIEludGVybmFsIGZ1bmN0aW9uIGV4ZWN1dGVkIGF0IHRoZSBlbmQgb2YgdGhlIGNoYWluXG4qIFRoaXMgY2FuIG9jY3VyIGVpdGhlciBpbiBzZXF1ZW5jZSAoaS5lLiBubyBlcnJvcnMpIG9yIGEganVtcCB0byB0aGlzIHBvc2l0aW9uIChpLmUuIGFuIGVycm9yIGhhcHBlbmVkIHNvbWV3aGVyZSlcbiogQGFjY2VzcyBwcml2YXRlXG4qL1xuZnVuY3Rpb24gX2ZpbmFsaXplKGVycikge1xuXHQvLyBTYW5pdHkgY2hlY2tzIHt7e1xuXHRpZiAodGhpcy5fc3RydWN0Lmxlbmd0aCA9PSAwKSByZXR1cm47IC8vIEZpbmFsaXplIGNhbGxlZCBvbiBkZWFkIG9iamVjdCAtIHByb2JhYmx5IGEgZGVmZXIoKSBmaXJlZCB3aXRob3V0IGFuIGF3YWl0KClcblx0aWYgKHRoaXMuX3N0cnVjdFt0aGlzLl9zdHJ1Y3QubGVuZ3RoIC0gMV0udHlwZSAhPSAnZW5kJykge1xuXHRcdHRocm93IG5ldyBFcnJvcignV2hpbGUgdHJ5aW5nIHRvIGZpbmQgYW4gZW5kIHBvaW50IGluIHRoZSBhc3luYy1jaGFpbmFibGUgc3RydWN0dXJlIHRoZSBsYXN0IGl0ZW0gaW4gdGhlIHRoaXMuX3N0cnVjdCBkb2VzIG5vdCBoYXZlIHR5cGU9PWVuZCEnKTtcblx0XHRyZXR1cm47XG5cdH1cblx0Ly8gfX19XG5cdHRoaXMuX3N0cnVjdFt0aGlzLl9zdHJ1Y3QubGVuZ3RoLTFdLnBheWxvYWQuY2FsbCh0aGlzLl9vcHRpb25zLmNvbnRleHQsIGVycik7XG5cdGlmICh0aGlzLl9vcHRpb25zLmF1dG9SZXNldClcblx0XHR0aGlzLnJlc2V0KCk7XG59O1xuXG5cbi8qKlxuKiBJbnRlcm5hbCBmdW5jdGlvbiB0byBleGVjdXRlIHRoZSBuZXh0IHBlbmRpbmcgcXVldWUgaXRlbVxuKiBUaGlzIGlzIHVzdWFsbHkgY2FsbGVkIGFmdGVyIHRoZSBjb21wbGV0aW9uIG9mIGV2ZXJ5IGFzeW5jLnNlcmllcygpIC8gYXN5bmMucGFyYWxsZWwoKSAvIGFzeW5jQ2hhaW5hYmxlLl9ydW4gY2FsbFxuKiBAYWNjZXNzIHByaXZhdGVcbiovXG5mdW5jdGlvbiBfZXhlY3V0ZShlcnIpIHtcblx0dmFyIHNlbGYgPSB0aGlzO1xuXHRpZiAoZXJyKSByZXR1cm4gdGhpcy5fZmluYWxpemUoZXJyKTsgLy8gQW4gZXJyb3IgaGFzIGJlZW4gcmFpc2VkIC0gc3RvcCBleGVjIGFuZCBjYWxsIGZpbmFsaXplIG5vd1xuXHRkbyB7XG5cdFx0dmFyIHJlZG8gPSBmYWxzZTtcblx0XHRpZiAoc2VsZi5fc3RydWN0UG9pbnRlciA+PSBzZWxmLl9zdHJ1Y3QubGVuZ3RoKSByZXR1cm4gdGhpcy5fZmluYWxpemUoZXJyKTsgLy8gTm90aGluZyBtb3JlIHRvIGV4ZWN1dGUgaW4gc3RydWN0XG5cdFx0c2VsZi5fZGVmZXJDaGVjaygpOyAvLyBLaWNrIG9mZiBhbnkgcGVuZGluZyBkZWZlcnJlZCBpdGVtc1xuXHRcdHZhciBjdXJyZW50RXhlYyA9IHNlbGYuX3N0cnVjdFtzZWxmLl9zdHJ1Y3RQb2ludGVyXTtcblx0XHQvLyBTYW5pdHkgY2hlY2tzIHt7e1xuXHRcdGlmICghY3VycmVudEV4ZWMudHlwZSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdObyB0eXBlIGlzIHNwZWNpZmllZCBmb3IgYXN5bmMtY2hhaW5hYmxlIHN0cnVjdHVyZSBhdCBvZmZzZXQgJyArIHNlbGYuX3N0cnVjdFBvaW50ZXIpO1xuXHRcdFx0cmV0dXJuIHNlbGY7XG5cdFx0fVxuXHRcdC8vIH19fVxuXHRcdHNlbGYuX3N0cnVjdFBvaW50ZXIrKztcblxuXHRcdC8vIFNraXAgc3RlcCB3aGVuIGZ1bmN0aW9uIHN1cHBvcnRzIHNraXBwaW5nIGlmIHRoZSBhcmd1bWVudCBpcyBlbXB0eSB7e3tcblx0XHRpZiAoXG5cdFx0XHRbXG5cdFx0XHRcdCdwYXJhbGxlbEFycmF5JywgJ3BhcmFsbGVsT2JqZWN0JywgJ3BhcmFsbGVsQ29sbGVjdGlvbicsXG5cdFx0XHRcdCdmb3JFYWNoQXJyYXknLCAnZm9yRWFjaE9iamVjdCcsXG5cdFx0XHRcdCdzZXJpZXNBcnJheScsICdzZXJpZXNPYmplY3QnLCAnc2VyaWVzQ29sbGVjdGlvbicsXG5cdFx0XHRcdCdkZWZlckFycmF5JywgJ2RlZmVyT2JqZWN0JywgJ2RlZmVyQ29sbGVjdGlvbicsXG5cdFx0XHRcdCdzZXQnXG5cdFx0XHRdLmluZGV4T2YoY3VycmVudEV4ZWMudHlwZSkgPiAtMSAmJlxuXHRcdFx0KFxuXHRcdFx0XHQhY3VycmVudEV4ZWMucGF5bG9hZCB8fCAvLyBOb3Qgc2V0IE9SXG5cdFx0XHRcdChpc0FycmF5KGN1cnJlbnRFeGVjLnBheWxvYWQpICYmICFjdXJyZW50RXhlYy5wYXlsb2FkLmxlbmd0aCkgfHwgLy8gQW4gZW1wdHkgYXJyYXlcblx0XHRcdFx0KGlzT2JqZWN0KGN1cnJlbnRFeGVjLnBheWxvYWQpICYmICFPYmplY3Qua2V5cyhjdXJyZW50RXhlYy5wYXlsb2FkKS5sZW5ndGgpIC8vIEFuIGVtcHR5IG9iamVjdFxuXHRcdFx0KVxuXHRcdCkge1xuXHRcdFx0Y3VycmVudEV4ZWMuY29tcGxldGVkID0gdHJ1ZTtcblx0XHRcdHJlZG8gPSB0cnVlO1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXHRcdC8vIH19fVxuXG5cdFx0c3dpdGNoIChjdXJyZW50RXhlYy50eXBlKSB7XG5cdFx0XHRjYXNlICdwYXJhbGxlbEFycmF5Jzpcblx0XHRcdFx0c2VsZi5fcnVuKGN1cnJlbnRFeGVjLnBheWxvYWQubWFwKGZ1bmN0aW9uKHRhc2spIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24obmV4dCkge1xuXHRcdFx0XHRcdFx0dGFzay5jYWxsKHNlbGYuX29wdGlvbnMuY29udGV4dCwgbmV4dCk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSksIHNlbGYuX29wdGlvbnMubGltaXQsIGZ1bmN0aW9uKGVycikge1xuXHRcdFx0XHRcdGN1cnJlbnRFeGVjLmNvbXBsZXRlZCA9IHRydWU7XG5cdFx0XHRcdFx0c2VsZi5fZXhlY3V0ZShlcnIpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdwYXJhbGxlbE9iamVjdCc6XG5cdFx0XHRcdHZhciB0YXNrcyA9IFtdO1xuXHRcdFx0XHRPYmplY3Qua2V5cyhjdXJyZW50RXhlYy5wYXlsb2FkKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0XHRcdHRhc2tzLnB1c2goZnVuY3Rpb24obmV4dCkge1xuXHRcdFx0XHRcdFx0Y3VycmVudEV4ZWMucGF5bG9hZFtrZXldLmNhbGwoc2VsZi5fb3B0aW9ucy5jb250ZXh0LCBmdW5jdGlvbihlcnIsIHZhbHVlKSB7XG5cdFx0XHRcdFx0XHRcdHNlbGYuX3NldChrZXksIHZhbHVlKTsgLy8gQWxsb2NhdGUgcmV0dXJuZWQgdmFsdWUgdG8gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRuZXh0KGVycik7XG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0c2VsZi5fcnVuKHRhc2tzLCBzZWxmLl9vcHRpb25zLmxpbWl0LCBmdW5jdGlvbihlcnIpIHtcblx0XHRcdFx0XHRjdXJyZW50RXhlYy5jb21wbGV0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdHNlbGYuX2V4ZWN1dGUoZXJyKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAncGFyYWxsZWxDb2xsZWN0aW9uJzpcblx0XHRcdFx0dmFyIHRhc2tzID0gW107XG5cdFx0XHRcdGN1cnJlbnRFeGVjLnBheWxvYWQuZm9yRWFjaChmdW5jdGlvbih0YXNrKSB7XG5cdFx0XHRcdFx0T2JqZWN0LmtleXModGFzaykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHRcdFx0XHRcdHRhc2tzLnB1c2goZnVuY3Rpb24obmV4dCwgZXJyKSB7XG5cdFx0XHRcdFx0XHRcdGlmICh0eXBlb2YgdGFza1trZXldICE9ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcignQ29sbGVjdGlvbiBpdGVtIGZvciBwYXJhbGxlbCBleGVjIGlzIG5vdCBhIGZ1bmN0aW9uJywgY3VycmVudEV4ZWMucGF5bG9hZCk7XG5cdFx0XHRcdFx0XHRcdHRhc2tba2V5XS5jYWxsKHNlbGYuX29wdGlvbnMuY29udGV4dCwgZnVuY3Rpb24oZXJyLCB2YWx1ZSkge1xuXHRcdFx0XHRcdFx0XHRcdHNlbGYuX3NldChrZXksIHZhbHVlKTsgLy8gQWxsb2NhdGUgcmV0dXJuZWQgdmFsdWUgdG8gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdG5leHQoZXJyKTtcblx0XHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0c2VsZi5fcnVuKHRhc2tzLCBzZWxmLl9vcHRpb25zLmxpbWl0LCBmdW5jdGlvbihlcnIpIHtcblx0XHRcdFx0XHRjdXJyZW50RXhlYy5jb21wbGV0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdHNlbGYuX2V4ZWN1dGUoZXJyKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnZm9yRWFjaEFycmF5Jzpcblx0XHRcdFx0c2VsZi5fcnVuKGN1cnJlbnRFeGVjLnBheWxvYWQubWFwKGZ1bmN0aW9uKGl0ZW0sIGl0ZXIpIHtcblx0XHRcdFx0XHRzZWxmLl9jb250ZXh0Ll9pdGVtID0gaXRlbTtcblx0XHRcdFx0XHRzZWxmLl9jb250ZXh0Ll9rZXkgPSBpdGVyO1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbihuZXh0KSB7XG5cdFx0XHRcdFx0XHRjdXJyZW50RXhlYy5jYWxsYmFjay5jYWxsKHNlbGYuX29wdGlvbnMuY29udGV4dCwgbmV4dCwgaXRlbSwgaXRlcik7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSksIHNlbGYuX29wdGlvbnMubGltaXQsIGZ1bmN0aW9uKGVycikge1xuXHRcdFx0XHRcdGN1cnJlbnRFeGVjLmNvbXBsZXRlZCA9IHRydWU7XG5cdFx0XHRcdFx0c2VsZi5fZXhlY3V0ZShlcnIpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdmb3JFYWNoT2JqZWN0Jzpcblx0XHRcdFx0dmFyIHRhc2tzID0gW107XG5cdFx0XHRcdE9iamVjdC5rZXlzKGN1cnJlbnRFeGVjLnBheWxvYWQpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRcdFx0dGFza3MucHVzaChmdW5jdGlvbihuZXh0KSB7XG5cdFx0XHRcdFx0XHRzZWxmLl9jb250ZXh0Ll9pdGVtID0gY3VycmVudEV4ZWMucGF5bG9hZFtrZXldO1xuXHRcdFx0XHRcdFx0c2VsZi5fY29udGV4dC5fa2V5ID0ga2V5O1xuXHRcdFx0XHRcdFx0Y3VycmVudEV4ZWMuY2FsbGJhY2suY2FsbChzZWxmLl9vcHRpb25zLmNvbnRleHQsIGZ1bmN0aW9uKGVyciwgdmFsdWUpIHtcblx0XHRcdFx0XHRcdFx0c2VsZi5fc2V0KGtleSwgdmFsdWUpOyAvLyBBbGxvY2F0ZSByZXR1cm5lZCB2YWx1ZSB0byBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdG5leHQoZXJyKTtcblx0XHRcdFx0XHRcdH0sIGN1cnJlbnRFeGVjLnBheWxvYWRba2V5XSwga2V5KTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHNlbGYuX3J1bih0YXNrcywgc2VsZi5fb3B0aW9ucy5saW1pdCwgZnVuY3Rpb24oZXJyKSB7XG5cdFx0XHRcdFx0Y3VycmVudEV4ZWMuY29tcGxldGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRzZWxmLl9leGVjdXRlKGVycik7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2ZvckVhY2hMYXRlQm91bmQnOlxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0KCFjdXJyZW50RXhlYy5wYXlsb2FkIHx8ICFjdXJyZW50RXhlYy5wYXlsb2FkLmxlbmd0aCkgfHwgLy8gUGF5bG9hZCBpcyBibGFua1xuXHRcdFx0XHRcdCghc2VsZi5fY29udGV4dFtjdXJyZW50RXhlYy5wYXlsb2FkXSkgLy8gUGF5bG9hZCBkb2VzbnQgZXhpc3Qgd2l0aGluIGNvbnRleHRcblx0XHRcdFx0KSB7IC8vIEdvdG8gbmV4dCBjaGFpblxuXHRcdFx0XHRcdGN1cnJlbnRFeGVjLmNvbXBsZXRlZCA9IHRydWU7XG5cdFx0XHRcdFx0cmVkbyA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXBsYWNlIG93biBleGVjIGFycmF5IHdpdGggYWN0dWFsIHR5cGUgb2YgcGF5bG9hZCBub3cgd2Uga25vdyB3aGF0IGl0IGlzIHt7e1xuXHRcdFx0XHR2YXIgb3ZlcmxvYWRUeXBlID0gZ2V0T3ZlcmxvYWQoW3NlbGYuX2NvbnRleHRbY3VycmVudEV4ZWMucGF5bG9hZF1dKTtcblx0XHRcdFx0c3dpdGNoIChvdmVybG9hZFR5cGUpIHtcblx0XHRcdFx0XHRjYXNlICdjb2xsZWN0aW9uJzpcblx0XHRcdFx0XHRjYXNlICdhcnJheSc6XG5cdFx0XHRcdFx0XHRjdXJyZW50RXhlYy50eXBlID0gJ2ZvckVhY2hBcnJheSc7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdvYmplY3QnOlxuXHRcdFx0XHRcdFx0Y3VycmVudEV4ZWMudHlwZSA9ICdmb3JFYWNoT2JqZWN0Jztcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBwZXJmb3JtIGZvckVhY2ggb3ZlciB1bmtub3duIG9iamVjdCB0eXBlOiAnICsgb3ZlcmxvYWRUeXBlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjdXJyZW50RXhlYy5wYXlsb2FkID0gc2VsZi5fY29udGV4dFtjdXJyZW50RXhlYy5wYXlsb2FkXTtcblx0XHRcdFx0c2VsZi5fc3RydWN0UG9pbnRlci0tOyAvLyBGb3JjZSByZS1ldmFsIG9mIHRoaXMgY2hhaW4gaXRlbSBub3cgaXRzIGJlZW4gcmVwbGFjZSB3aXRoIGl0cyByZWFsIChsYXRlLWJvdW5kKSB0eXBlXG5cdFx0XHRcdHJlZG8gPSB0cnVlO1xuXHRcdFx0XHQvLyB9fX1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdzZXJpZXNBcnJheSc6XG5cdFx0XHRcdHNlbGYuX3J1bihjdXJyZW50RXhlYy5wYXlsb2FkLm1hcChmdW5jdGlvbih0YXNrKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKG5leHQpIHtcblx0XHRcdFx0XHRcdHRhc2suY2FsbChzZWxmLl9vcHRpb25zLmNvbnRleHQsIG5leHQpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0pLCAxLCBmdW5jdGlvbihlcnIpIHtcblx0XHRcdFx0XHRjdXJyZW50RXhlYy5jb21wbGV0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdHNlbGYuX2V4ZWN1dGUoZXJyKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnc2VyaWVzT2JqZWN0Jzpcblx0XHRcdFx0dmFyIHRhc2tzID0gW107XG5cdFx0XHRcdE9iamVjdC5rZXlzKGN1cnJlbnRFeGVjLnBheWxvYWQpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRcdFx0dGFza3MucHVzaChmdW5jdGlvbihuZXh0KSB7XG5cdFx0XHRcdFx0XHRjdXJyZW50RXhlYy5wYXlsb2FkW2tleV0uY2FsbChzZWxmLl9vcHRpb25zLmNvbnRleHQsIGZ1bmN0aW9uKGVyciwgdmFsdWUpIHtcblx0XHRcdFx0XHRcdFx0c2VsZi5fc2V0KGtleSwgdmFsdWUpOyAvLyBBbGxvY2F0ZSByZXR1cm5lZCB2YWx1ZSB0byBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdG5leHQoZXJyKTtcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRzZWxmLl9ydW4odGFza3MsIDEsIGZ1bmN0aW9uKGVycikge1xuXHRcdFx0XHRcdGN1cnJlbnRFeGVjLmNvbXBsZXRlZCA9IHRydWU7XG5cdFx0XHRcdFx0c2VsZi5fZXhlY3V0ZShlcnIpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdzZXJpZXNDb2xsZWN0aW9uJzpcblx0XHRcdFx0dmFyIHRhc2tzID0gW107XG5cdFx0XHRcdGN1cnJlbnRFeGVjLnBheWxvYWQuZm9yRWFjaChmdW5jdGlvbih0YXNrKSB7XG5cdFx0XHRcdFx0T2JqZWN0LmtleXModGFzaykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHRcdFx0XHRcdHRhc2tzLnB1c2goZnVuY3Rpb24obmV4dCwgZXJyKSB7XG5cdFx0XHRcdFx0XHRcdGlmICh0eXBlb2YgdGFza1trZXldICE9ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcignQ29sbGVjdGlvbiBpdGVtIGZvciBzZXJpZXMgZXhlYyBpcyBub3QgYSBmdW5jdGlvbicsIGN1cnJlbnRFeGVjLnBheWxvYWQpO1xuXHRcdFx0XHRcdFx0XHR0YXNrW2tleV0uY2FsbChzZWxmLl9vcHRpb25zLmNvbnRleHQsIGZ1bmN0aW9uKGVyciwgdmFsdWUpIHtcblx0XHRcdFx0XHRcdFx0XHRzZWxmLl9zZXQoa2V5LCB2YWx1ZSk7IC8vIEFsbG9jYXRlIHJldHVybmVkIHZhbHVlIHRvIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRuZXh0KGVycik7XG5cdFx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHNlbGYuX3J1bih0YXNrcywgMSwgZnVuY3Rpb24oZXJyKSB7XG5cdFx0XHRcdFx0Y3VycmVudEV4ZWMuY29tcGxldGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRzZWxmLl9leGVjdXRlKGVycik7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2RlZmVyQXJyYXknOlxuXHRcdFx0XHRjdXJyZW50RXhlYy5wYXlsb2FkLmZvckVhY2goZnVuY3Rpb24odGFzaykge1xuXHRcdFx0XHRcdHNlbGYuX2RlZmVyQWRkKG51bGwsIHRhc2ssIGN1cnJlbnRFeGVjKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0cmVkbyA9IHRydWU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnZGVmZXJPYmplY3QnOlxuXHRcdFx0XHRPYmplY3Qua2V5cyhjdXJyZW50RXhlYy5wYXlsb2FkKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0XHRcdHNlbGYuX2RlZmVyQWRkKGtleSwgY3VycmVudEV4ZWMucGF5bG9hZFtrZXldLCBjdXJyZW50RXhlYyk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHJlZG8gPSB0cnVlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2RlZmVyQ29sbGVjdGlvbic6XG5cdFx0XHRcdGN1cnJlbnRFeGVjLnBheWxvYWQuZm9yRWFjaChmdW5jdGlvbih0YXNrKSB7XG5cdFx0XHRcdFx0T2JqZWN0LmtleXModGFzaykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHRcdFx0XHRcdHNlbGYuX2RlZmVyQWRkKGtleSwgdGFza1trZXldLCBjdXJyZW50RXhlYyk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZWRvID0gdHJ1ZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdhd2FpdCc6IC8vIEF3YWl0IGNhbiBvcGVyYXRlIGluIHR3byBtb2RlcywgZWl0aGVyIHBheWxvYWQ9W10gKGV4YW1pbmUgYWxsKSBlbHNlIChleGFtaW5lIHNwZWNpZmljIGtleXMpXG5cdFx0XHRcdGlmICghY3VycmVudEV4ZWMucGF5bG9hZC5sZW5ndGgpIHsgLy8gQ2hlY2sgYWxsIHRhc2tzIGFyZSBjb21wbGV0ZVxuXHRcdFx0XHRcdGlmIChzZWxmLl9zdHJ1Y3Quc2xpY2UoMCwgc2VsZi5fc3RydWN0UG9pbnRlciAtIDEpLmV2ZXJ5KGZ1bmN0aW9uKHN0YWdlKSB7IC8vIEV4YW1pbmUgYWxsIGl0ZW1zIFVQIFRPIHNlbGYgb25lIGFuZCBjaGVjayB0aGV5IGFyZSBjb21wbGV0ZVxuXHRcdFx0XHRcdFx0cmV0dXJuIHN0YWdlLmNvbXBsZXRlZDtcblx0XHRcdFx0XHR9KSkgeyAvLyBBbGwgdGFza3MgdXAgdG8gc2VsZiBwb2ludCBhcmUgbWFya2VkIGFzIGNvbXBsZXRlZFxuXHRcdFx0XHRcdFx0Y3VycmVudEV4ZWMuY29tcGxldGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHJlZG8gPSB0cnVlO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZWxmLl9zdHJ1Y3RQb2ludGVyLS07IC8vIEF0IGxlYXN0IG9uZSB0YXNrIGlzIG91dHN0YW5kaW5nIC0gcmV3aW5kIHRvIHNlbGYgc3RhZ2Ugc28gd2UgcmVwZWF0IG9uIG5leHQgcmVzb2x1dGlvblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHsgLy8gQ2hlY2sgY2VydGFpbiB0YXNrcyBhcmUgY29tcGxldGUgYnkga2V5XG5cdFx0XHRcdFx0aWYgKGN1cnJlbnRFeGVjLnBheWxvYWQuZXZlcnkoZnVuY3Rpb24oZGVwKSB7IC8vIEV4YW1pbmUgYWxsIG5hbWVkIGRlcGVuZGVuY2llc1xuXHRcdFx0XHRcdFx0cmV0dXJuICEhIHNlbGYuX2NvbnRleHRbZGVwXTtcblx0XHRcdFx0XHR9KSkgeyAvLyBBbGwgYXJlIHByZXNlbnRcblx0XHRcdFx0XHRcdGN1cnJlbnRFeGVjLmNvbXBsZXRlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRyZWRvID0gdHJ1ZTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5fc3RydWN0UG9pbnRlci0tOyAvLyBBdCBsZWFzdCBvbmUgZGVwZW5kZW5jeSBpcyBvdXRzdGFuZGluZyAtIHJld2luZCB0byBzZWxmIHN0YWdlIHNvIHdlIHJlcGVhdCBvbiBuZXh0IHJlc29sdXRpb25cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdsaW1pdCc6IC8vIFNldCB0aGUgb3B0aW9ucy5saW1pdCB2YXJpYWJsZVxuXHRcdFx0XHRzZWxmLl9vcHRpb25zLmxpbWl0ID0gY3VycmVudEV4ZWMucGF5bG9hZDtcblx0XHRcdFx0Y3VycmVudEV4ZWMuY29tcGxldGVkID0gdHJ1ZTtcblx0XHRcdFx0cmVkbyA9IHRydWU7IC8vIE1vdmUgb24gdG8gbmV4dCBhY3Rpb25cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdjb250ZXh0JzogLy8gQ2hhbmdlIHRoZSBzZWxmLl9vcHRpb25zLmNvbnRleHQgb2JqZWN0XG5cdFx0XHRcdHNlbGYuX29wdGlvbnMuY29udGV4dCA9IGN1cnJlbnRFeGVjLnBheWxvYWQgPyBjdXJyZW50RXhlYy5wYXlsb2FkIDogc2VsZi5fY29udGV4dDsgLy8gU2V0IGNvbnRleHQgKGlmIG51bGwgdXNlIGludGVybmFsIGNvbnRleHQpXG5cdFx0XHRcdGN1cnJlbnRFeGVjLmNvbXBsZXRlZCA9IHRydWU7XG5cdFx0XHRcdHJlZG8gPSB0cnVlOyAvLyBNb3ZlIG9uIHRvIG5leHQgYWN0aW9uXG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnc2V0JzogLy8gU2V0IGEgaGFzaCBvZiB2YXJpYWJsZXMgd2l0aGluIGNvbnRleHRcblx0XHRcdFx0T2JqZWN0LmtleXMoY3VycmVudEV4ZWMucGF5bG9hZCkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHRcdFx0XHRzZWxmLl9zZXQoa2V5LCBjdXJyZW50RXhlYy5wYXlsb2FkW2tleV0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0Y3VycmVudEV4ZWMuY29tcGxldGVkID0gdHJ1ZTtcblx0XHRcdFx0cmVkbyA9IHRydWU7IC8vIE1vdmUgb24gdG8gbmV4dCBhY3Rpb25cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdlbmQnOiAvLyBzZWxmIHNob3VsZCBBTFdBWVMgYmUgdGhlIGxhc3QgaXRlbSBpbiB0aGUgc3RydWN0dXJlIGFuZCBpbmRpY2F0ZXMgdGhlIGZpbmFsIGZ1bmN0aW9uIGNhbGxcblx0XHRcdFx0dGhpcy5fZmluYWxpemUoKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRpZiAodGhpcy5fcGx1Z2luc1tjdXJyZW50RXhlYy50eXBlXSkgeyAvLyBJcyB0aGVyZSBhIHBsdWdpbiB0aGF0IHNob3VsZCBtYW5hZ2UgdGhpcz9cblx0XHRcdFx0XHR0aGlzLl9wbHVnaW5zW2N1cnJlbnRFeGVjLnR5cGVdLmNhbGwodGhpcywgY3VycmVudEV4ZWMpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5rbm93biBhc3luYy1jaGFpbmFibGUgZXhlYyB0eXBlOiAnICsgY3VycmVudEV4ZWMudHlwZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0fSB3aGlsZSAocmVkbyk7XG59O1xuXG5cbi8qKlxuKiBJbnRlcm5hbCBmdW5jdGlvbiB0byBydW4gYW4gYXJyYXkgb2YgZnVuY3Rpb25zICh1c3VhbGx5IGluIHBhcmFsbGVsKVxuKiBTZXJpZXMgZXhlY3V0aW9uIGNhbiBiZSBvYnRhaW5lZCBieSBzZXR0aW5nIGxpbWl0ID0gMVxuKiBAcGFyYW0gYXJyYXkgdGFza3MgVGhlIGFycmF5IG9mIHRhc2tzIHRvIGV4ZWN1dGVcbiogQHBhcmFtIGludCBsaW1pdCBUaGUgbGltaXRlciBvZiB0YXNrcyAoaWYgbGltaXQ9PTEgdGFza3MgYXJlIHJ1biBpbiBzZXJpZXMsIGlmIGxpbWl0PjEgdGFza3MgYXJlIHJ1biBpbiBsaW1pdGVkIHBhcmFsbGVsLCBlbHNlIHRhc2tzIGFyZSBydW4gaW4gcGFyYWxsZWwpXG4qIEBwYXJhbSBmdW5jdGlvbiBjYWxsYmFjayhlcnIpIFRoZSBjYWxsYmFjayB0byBmaXJlIG9uIGZpbmlzaFxuKi9cbmZ1bmN0aW9uIF9ydW4odGFza3MsIGxpbWl0LCBjYWxsYmFjaykge1xuXHRpZiAobGltaXQgPT0gMSkge1xuXHRcdGFzeW5jLnNlcmllcyh0YXNrcywgY2FsbGJhY2spO1xuXHR9IGVsc2UgaWYgKGxpbWl0ID4gMCkge1xuXHRcdGFzeW5jLnBhcmFsbGVsTGltaXQodGFza3MsIGxpbWl0LCBjYWxsYmFjayk7XG5cdH0gZWxzZSB7XG5cdFx0YXN5bmMucGFyYWxsZWwodGFza3MsIGNhbGxiYWNrKTtcblx0fVxufVxuXG5cbi8qKlxuKiBSZXNldCBhbGwgc3RhdGUgdmFyaWFibGVzIGFuZCByZXR1cm4gdGhlIG9iamVjdCBpbnRvIGEgcHJpc3RpbmUgY29uZGl0aW9uXG4qIEByZXR1cm4gb2JqZWN0IFRoaXMgY2hhaW5hYmxlIG9iamVjdFxuKi9cbmZ1bmN0aW9uIHJlc2V0KCkge1xuXHR0aGlzLl9zdHJ1Y3QgPSBbXTtcblx0dGhpcy5fc3RydWN0UG9pbnRlciA9IDA7XG5cblx0dmFyIHJlQXR0YWNoQ29udGV4dCA9ICh0aGlzLl9vcHRpb25zLmNvbnRleHQgPT0gdGhpcy5fY29udGV4dCk7IC8vIFJlYXR0YWNoIHRoZSBjb250ZXh0IHBvaW50ZXIgYWZ0ZXIgcmVzZXQ/XG5cdHRoaXMuX2NvbnRleHQgPSB7XG5cdFx0X3N0cnVjdDogdGhpcy5fc3RydWN0LFxuXHRcdF9zdHJ1Y3RQb2ludGVyOiB0aGlzLl9zdHJ1Y3RQb2ludGVyLFxuXHRcdF9vcHRpb25zOiB0aGlzLl9vcHRpb25zLFxuXHRcdF9kZWZlcnJlZFJ1bm5pbmc6IHRoaXMuX2RlZmVycmVkUnVubmluZyxcblx0fTtcblxuXHRpZiAocmVBdHRhY2hDb250ZXh0KSB0aGlzLl9vcHRpb25zLmNvbnRleHQgPSB0aGlzLl9jb250ZXh0O1xufTtcblxuLyoqXG4qIFF1ZXVlIHVwIGFuIG9wdGlvbmFsIHNpbmdsZSBmdW5jdGlvbiBmb3IgZXhlY3V0aW9uIG9uIGNvbXBsZXRpb25cbiogVGhpcyBmdW5jdGlvbiBhbHNvIHN0YXJ0cyB0aGUgcXVldWUgZXhlY3V0aW5nXG4qIEByZXR1cm4gb2JqZWN0IFRoaXMgY2hhaW5hYmxlIG9iamVjdFxuKi9cbmZ1bmN0aW9uIGVuZCgpIHsgXG5cdHZhciBjYWxsZWRBcyA9IGdldE92ZXJsb2FkKGFyZ3VtZW50cyk7XG5cdHN3aXRjaCAoY2FsbGVkQXMpIHtcblx0XHRjYXNlICcnOiAvLyBObyBmdW5jdGlvbnMgcGFzc2VkIC0gZG8gbm90aGluZ1xuXHRcdFx0dGhpcy5fc3RydWN0LnB1c2goeyB0eXBlOiAnZW5kJywgcGF5bG9hZDogZnVuY3Rpb24oKSB7fSB9KTsgLy8gLmVuZCgpIGNhbGxlZCB3aXRoIG5vIGFyZ3MgLSBtYWtlIGEgbm9vcCgpXG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdmdW5jdGlvbic6IC8vIEZvcm06IGVuZChmdW5jKSAtPiByZWRpcmVjdCBhcyBpZiBjYWxsZWQgd2l0aCBzZXJpZXMoZnVuYylcblx0XHRcdHRoaXMuX3N0cnVjdC5wdXNoKHsgdHlwZTogJ2VuZCcsIHBheWxvYWQ6IGFyZ3VtZW50c1swXSB9KTtcblx0XHRcdGJyZWFrO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gY2FsbCBzdHlsZSBmb3IgLmVuZCgpOiAnICsgY2FsbGVkQXMpO1xuXHR9XG5cblx0dGhpcy5fZXhlY3V0ZSgpO1xuXHRyZXR1cm4gdGhpcztcbn07XG5cbnZhciBvYmplY3RJbnN0YW5jZSA9IGZ1bmN0aW9uKCkge1xuXHQvLyBWYXJpYWJsZXMge3t7XG5cdHRoaXMuX3N0cnVjdCA9IFtdO1xuXHR0aGlzLl9zdHJ1Y3RQb2ludGVyID0gMDtcblx0dGhpcy5fY29udGV4dCA9IHt9O1xuXG5cdHRoaXMuX29wdGlvbnMgPSB7XG5cdFx0YXV0b1Jlc2V0OiB0cnVlLCAvLyBSdW4gYXN5bmNDaGFpbmFibGUucmVzZXQoKSBhZnRlciBmaW5hbGl6ZS4gRGlzYWJsZSB0aGlzIGlmIHlvdSB3YW50IHRvIHNlZSBhIHBvc3QtbW9ydGVtIG9uIHdoYXQgZGlkIHJ1blxuXHRcdGxpbWl0OiAxMCwgLy8gTnVtYmVyIG9mIGRlZmVyIGZ1bmN0aW9ucyB0aGF0IGFyZSBhbGxvd2VkIHRvIGV4ZWN1dGUgYXQgb25jZVxuXHRcdGNvbnRleHQ6IHRoaXMuX2NvbnRleHQsIC8vIFRoZSBjb250ZXh0IGl0ZW0gcGFzc2VkIHRvIHRoZSBmdW5jdGlvbnMgKGNhbiBiZSBjaGFuZ2VkIHdpdGggLmNvbnRleHQoKSlcblx0fTtcblx0Ly8gfX19XG5cblx0Ly8gQXN5bmMtQ2hhaW5hYmxlIGZ1bmN0aW9ucyB7e3tcblx0Ly8gUHJpdmF0ZSB7e3tcblx0dGhpcy5fZXhlY3V0ZSA9IF9leGVjdXRlO1xuXHR0aGlzLl9ydW4gPSBfcnVuO1xuXHR0aGlzLl9kZWZlckNoZWNrID0gX2RlZmVyQ2hlY2s7XG5cdHRoaXMuX2RlZmVyQWRkID0gZGVmZXJBZGQ7XG5cdHRoaXMuX2RlZmVycmVkID0gW107XG5cdHRoaXMuX2RlZmVycmVkUnVubmluZyA9IDA7XG5cdHRoaXMuX2ZpbmFsaXplID0gX2ZpbmFsaXplO1xuXHR0aGlzLl9nZXRPdmVybG9hZCA9IGdldE92ZXJsb2FkOyAvLyBTbyB0aGlzIGZ1bmN0aW9uIGlzIGFjY2Vzc2libGUgYnkgcGx1Z2luc1xuXHR0aGlzLl9wbHVnaW5zID0gX3BsdWdpbnM7XG5cdC8vIH19fVxuXG5cdHRoaXMuYXdhaXQgPSBhd2FpdDtcblx0dGhpcy5jb250ZXh0ID0gc2V0Q29udGV4dDtcblx0dGhpcy5kZWZlciA9IGRlZmVyO1xuXHR0aGlzLmVuZCA9IGVuZDtcblx0dGhpcy5mb3JFYWNoID0gZm9yRWFjaDtcblx0dGhpcy5saW1pdCA9IHNldExpbWl0O1xuXHR0aGlzLnBhcmFsbGVsID0gcGFyYWxsZWw7XG5cdHRoaXMucmVzZXQgPSByZXNldDtcblx0dGhpcy5zZXJpZXMgPSBzZXJpZXM7XG5cdHRoaXMuc2V0ID0gc2V0O1xuXHR0aGlzLl9zZXQgPSBfc2V0O1xuXHR0aGlzLl9zZXRSYXcgPSBfc2V0UmF3O1xuXHR0aGlzLnRoZW4gPSBzZXJpZXM7XG5cdHRoaXMubmV3ID0gZnVuY3Rpb24oKSB7IHJldHVybiBuZXcgb2JqZWN0SW5zdGFuY2UgfTtcblx0dGhpcy51c2UgPSB1c2U7XG5cdC8vIH19fVxuXG5cdC8vIEFzeW5jIGNvbXBhdCBmdW5jdGlvbmFsaXR5IC0gc28gdGhpcyBtb2R1bGUgYmVjb21lcyBhIGRyb3AtaW4gcmVwbGFjZW1lbnQge3t7XG5cdC8vIENvbGxlY3Rpb25zXG5cdHRoaXMuZWFjaCA9IGFzeW5jLmVhY2g7XG5cdHRoaXMuZWFjaFNlcmllcyA9IGFzeW5jLmVhY2hTZXJpZXM7XG5cdHRoaXMuZWFjaExpbWl0ID0gYXN5bmMuZWFjaExpbWl0O1xuXHR0aGlzLm1hcCA9IGFzeW5jLm1hcDtcblx0dGhpcy5tYXBTZXJpZXMgPSBhc3luYy5tYXBTZXJpZXM7XG5cdHRoaXMubWFwTGltaXQgPSBhc3luYy5tYXBMaW1pdDtcblx0dGhpcy5maWx0ZXIgPSBhc3luYy5maWx0ZXI7XG5cdHRoaXMuZmlsdGVyU2VyaWVzID0gYXN5bmMuZmlsdGVyU2VyaWVzO1xuXHR0aGlzLnJlamVjdCA9IGFzeW5jLnJlamVjdDtcblx0dGhpcy5yZWplY3RTZXJpZXMgPSBhc3luYy5yZWplY3RTZXJpZXM7XG5cdHRoaXMucmVkdWNlID0gYXN5bmMucmVkdWNlO1xuXHR0aGlzLnJlZHVjZVJpZ2h0ID0gYXN5bmMucmVkdWNlUmlnaHQ7XG5cdHRoaXMuZGV0ZWN0ID0gYXN5bmMuZGV0ZWN0O1xuXHR0aGlzLmRldGVjdFNlcmllcyA9IGFzeW5jLmRldGVjdFNlcmllcztcblx0dGhpcy5zb3J0QnkgPSBhc3luYy5zb3J0Qnk7XG5cdHRoaXMuc29tZSA9IGFzeW5jLnNvbWU7XG5cdHRoaXMuZXZlcnkgPSBhc3luYy5ldmVyeTtcblx0dGhpcy5jb25jYXQgPSBhc3luYy5jb25jYXQ7XG5cdHRoaXMuY29uY2F0U2VyaWVzID0gYXN5bmMuY29uY2F0U2VyaWVzO1xuXG5cdC8vIENvbnRyb2wgRmxvd1xuXHQvLyBTZWUgbWFpbiAuc2VyaWVzKCkgYW5kIC5wYXJhbGxlbCgpIGNvZGUgZm9yIGFzeW5jIGNvbXBhdGliaWxpdHlcblx0dGhpcy5wYXJhbGxlbExpbWl0ID0gYXN5bmMucGFyYWxsZWxMaW1pdDtcblx0dGhpcy53aGlsc3QgPSBhc3luYy53aGlsc3Q7XG5cdHRoaXMuZG9XaGlsc3QgPSBhc3luYy5kb1doaWxzdDtcblx0dGhpcy51bnRpbCA9IGFzeW5jLnVudGlsO1xuXHR0aGlzLmRvVW50aWwgPSBhc3luYy5kb1VudGlsO1xuXHR0aGlzLmZvcmV2ZXIgPSBhc3luYy5mb3JldmVyO1xuXHR0aGlzLndhdGVyZmFsbCA9IGFzeW5jLndhdGVyZmFsbDtcblx0dGhpcy5jb21wb3NlID0gYXN5bmMuY29tcG9zZTtcblx0dGhpcy5zZXEgPSBhc3luYy5zZXE7XG5cdHRoaXMuYXBwbHlFYWNoID0gYXN5bmMuYXBwbHlFYWNoO1xuXHR0aGlzLmFwcGx5RWFjaFNlcmllcyA9IGFzeW5jLmFwcGx5RWFjaFNlcmllcztcblx0dGhpcy5xdWV1ZSA9IGFzeW5jLnF1ZXVlO1xuXHR0aGlzLnByaW9yaXR5UXVldWUgPSBhc3luYy5wcmlvcml0eVF1ZXVlO1xuXHR0aGlzLmNhcmdvID0gYXN5bmMuY2FyZ287XG5cdHRoaXMuYXV0byA9IGFzeW5jLmF1dG87XG5cdHRoaXMucmV0cnkgPSBhc3luYy5yZXRyeTtcblx0dGhpcy5pdGVyYXRvciA9IGFzeW5jLml0ZXJhdG9yO1xuXHR0aGlzLmFwcGx5ID0gYXN5bmMuYXBwbHk7XG5cdHRoaXMubmV4dFRpY2sgPSBhc3luYy5uZXh0VGljaztcblx0dGhpcy50aW1lcyA9IGFzeW5jLnRpbWVzO1xuXHR0aGlzLnRpbWVzU2VyaWVzID0gYXN5bmMudGltZXNTZXJpZXM7XG5cdHRoaXMuVXRpbHMgPSBhc3luYy5VdGlscztcblxuXHQvLyBVdGlsc1xuXHR0aGlzLm1lbW9pemUgPSBhc3luYy5tZW1vaXplO1xuXHR0aGlzLnVubWVtb2l6ZSA9IGFzeW5jLnVubWVtb2l6ZTtcblx0dGhpcy5sb2cgPSBhc3luYy5sb2c7XG5cdHRoaXMuZGlyID0gYXN5bmMuZGlyO1xuXHR0aGlzLm5vQ29uZmxpY3QgPSBhc3luYy5ub0NvbmZsaWN0O1xuXHQvLyB9fX1cblxuXHR0aGlzLnJlc2V0KCk7XG5cdHJldHVybiB0aGlzO1xufVxuXG4vLyBSZXR1cm4gdGhlIG91dHB1dCBvYmplY3Rcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYXN5bmNDaGFpbmFibGUoKSB7XG5cdHJldHVybiBuZXcgb2JqZWN0SW5zdGFuY2U7XG59O1xuIiwiLyohXG4gKiBhc3luY1xuICogaHR0cHM6Ly9naXRodWIuY29tL2Nhb2xhbi9hc3luY1xuICpcbiAqIENvcHlyaWdodCAyMDEwLTIwMTQgQ2FvbGFuIE1jTWFob25cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG4oZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGFzeW5jID0ge307XG4gICAgZnVuY3Rpb24gbm9vcCgpIHt9XG4gICAgZnVuY3Rpb24gaWRlbnRpdHkodikge1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgZnVuY3Rpb24gdG9Cb29sKHYpIHtcbiAgICAgICAgcmV0dXJuICEhdjtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm90SWQodikge1xuICAgICAgICByZXR1cm4gIXY7XG4gICAgfVxuXG4gICAgLy8gZ2xvYmFsIG9uIHRoZSBzZXJ2ZXIsIHdpbmRvdyBpbiB0aGUgYnJvd3NlclxuICAgIHZhciBwcmV2aW91c19hc3luYztcblxuICAgIC8vIEVzdGFibGlzaCB0aGUgcm9vdCBvYmplY3QsIGB3aW5kb3dgIChgc2VsZmApIGluIHRoZSBicm93c2VyLCBgZ2xvYmFsYFxuICAgIC8vIG9uIHRoZSBzZXJ2ZXIsIG9yIGB0aGlzYCBpbiBzb21lIHZpcnR1YWwgbWFjaGluZXMuIFdlIHVzZSBgc2VsZmBcbiAgICAvLyBpbnN0ZWFkIG9mIGB3aW5kb3dgIGZvciBgV2ViV29ya2VyYCBzdXBwb3J0LlxuICAgIHZhciByb290ID0gdHlwZW9mIHNlbGYgPT09ICdvYmplY3QnICYmIHNlbGYuc2VsZiA9PT0gc2VsZiAmJiBzZWxmIHx8XG4gICAgICAgICAgICB0eXBlb2YgZ2xvYmFsID09PSAnb2JqZWN0JyAmJiBnbG9iYWwuZ2xvYmFsID09PSBnbG9iYWwgJiYgZ2xvYmFsIHx8XG4gICAgICAgICAgICB0aGlzO1xuXG4gICAgaWYgKHJvb3QgIT0gbnVsbCkge1xuICAgICAgICBwcmV2aW91c19hc3luYyA9IHJvb3QuYXN5bmM7XG4gICAgfVxuXG4gICAgYXN5bmMubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcm9vdC5hc3luYyA9IHByZXZpb3VzX2FzeW5jO1xuICAgICAgICByZXR1cm4gYXN5bmM7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG9ubHlfb25jZShmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoZm4gPT09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIkNhbGxiYWNrIHdhcyBhbHJlYWR5IGNhbGxlZC5cIik7XG4gICAgICAgICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgZm4gPSBudWxsO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9vbmNlKGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChmbiA9PT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGZuID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLy8vIGNyb3NzLWJyb3dzZXIgY29tcGF0aWJsaXR5IGZ1bmN0aW9ucyAvLy8vXG5cbiAgICB2YXIgX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuICAgIHZhciBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9O1xuXG4gICAgLy8gUG9ydGVkIGZyb20gdW5kZXJzY29yZS5qcyBpc09iamVjdFxuICAgIHZhciBfaXNPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2Ygb2JqO1xuICAgICAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlID09PSAnb2JqZWN0JyAmJiAhIW9iajtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gX2lzQXJyYXlMaWtlKGFycikge1xuICAgICAgICByZXR1cm4gX2lzQXJyYXkoYXJyKSB8fCAoXG4gICAgICAgICAgICAvLyBoYXMgYSBwb3NpdGl2ZSBpbnRlZ2VyIGxlbmd0aCBwcm9wZXJ0eVxuICAgICAgICAgICAgdHlwZW9mIGFyci5sZW5ndGggPT09IFwibnVtYmVyXCIgJiZcbiAgICAgICAgICAgIGFyci5sZW5ndGggPj0gMCAmJlxuICAgICAgICAgICAgYXJyLmxlbmd0aCAlIDEgPT09IDBcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfYXJyYXlFYWNoKGFyciwgaXRlcmF0b3IpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBhcnIubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihhcnJbaW5kZXhdLCBpbmRleCwgYXJyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9tYXAoYXJyLCBpdGVyYXRvcikge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGFyci5sZW5ndGgsXG4gICAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0b3IoYXJyW2luZGV4XSwgaW5kZXgsIGFycik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfcmFuZ2UoY291bnQpIHtcbiAgICAgICAgcmV0dXJuIF9tYXAoQXJyYXkoY291bnQpLCBmdW5jdGlvbiAodiwgaSkgeyByZXR1cm4gaTsgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3JlZHVjZShhcnIsIGl0ZXJhdG9yLCBtZW1vKSB7XG4gICAgICAgIF9hcnJheUVhY2goYXJyLCBmdW5jdGlvbiAoeCwgaSwgYSkge1xuICAgICAgICAgICAgbWVtbyA9IGl0ZXJhdG9yKG1lbW8sIHgsIGksIGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2ZvckVhY2hPZihvYmplY3QsIGl0ZXJhdG9yKSB7XG4gICAgICAgIF9hcnJheUVhY2goX2tleXMob2JqZWN0KSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaXRlcmF0b3Iob2JqZWN0W2tleV0sIGtleSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9pbmRleE9mKGFyciwgaXRlbSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGFycltpXSA9PT0gaXRlbSkgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIHZhciBfa2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgayBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2goayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9rZXlJdGVyYXRvcihjb2xsKSB7XG4gICAgICAgIHZhciBpID0gLTE7XG4gICAgICAgIHZhciBsZW47XG4gICAgICAgIHZhciBrZXlzO1xuICAgICAgICBpZiAoX2lzQXJyYXlMaWtlKGNvbGwpKSB7XG4gICAgICAgICAgICBsZW4gPSBjb2xsLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gaSA8IGxlbiA/IGkgOiBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGtleXMgPSBfa2V5cyhjb2xsKTtcbiAgICAgICAgICAgIGxlbiA9IGtleXMubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIHJldHVybiBpIDwgbGVuID8ga2V5c1tpXSA6IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2ltaWxhciB0byBFUzYncyByZXN0IHBhcmFtIChodHRwOi8vYXJpeWEub2ZpbGFicy5jb20vMjAxMy8wMy9lczYtYW5kLXJlc3QtcGFyYW1ldGVyLmh0bWwpXG4gICAgLy8gVGhpcyBhY2N1bXVsYXRlcyB0aGUgYXJndW1lbnRzIHBhc3NlZCBpbnRvIGFuIGFycmF5LCBhZnRlciBhIGdpdmVuIGluZGV4LlxuICAgIC8vIEZyb20gdW5kZXJzY29yZS5qcyAoaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL3B1bGwvMjE0MCkuXG4gICAgZnVuY3Rpb24gX3Jlc3RQYXJhbShmdW5jLCBzdGFydEluZGV4KSB7XG4gICAgICAgIHN0YXJ0SW5kZXggPSBzdGFydEluZGV4ID09IG51bGwgPyBmdW5jLmxlbmd0aCAtIDEgOiArc3RhcnRJbmRleDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IE1hdGgubWF4KGFyZ3VtZW50cy5sZW5ndGggLSBzdGFydEluZGV4LCAwKTtcbiAgICAgICAgICAgIHZhciByZXN0ID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICByZXN0W2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleCArIHN0YXJ0SW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChzdGFydEluZGV4KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIHJlc3QpO1xuICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzLCBhcmd1bWVudHNbMF0sIHJlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ3VycmVudGx5IHVudXNlZCBidXQgaGFuZGxlIGNhc2VzIG91dHNpZGUgb2YgdGhlIHN3aXRjaCBzdGF0ZW1lbnQ6XG4gICAgICAgICAgICAvLyB2YXIgYXJncyA9IEFycmF5KHN0YXJ0SW5kZXggKyAxKTtcbiAgICAgICAgICAgIC8vIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHN0YXJ0SW5kZXg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIC8vICAgICBhcmdzW2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAvLyBhcmdzW3N0YXJ0SW5kZXhdID0gcmVzdDtcbiAgICAgICAgICAgIC8vIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF93aXRob3V0SW5kZXgoaXRlcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0b3IodmFsdWUsIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLy8vIGV4cG9ydGVkIGFzeW5jIG1vZHVsZSBmdW5jdGlvbnMgLy8vL1xuXG4gICAgLy8vLyBuZXh0VGljayBpbXBsZW1lbnRhdGlvbiB3aXRoIGJyb3dzZXItY29tcGF0aWJsZSBmYWxsYmFjayAvLy8vXG5cbiAgICAvLyBjYXB0dXJlIHRoZSBnbG9iYWwgcmVmZXJlbmNlIHRvIGd1YXJkIGFnYWluc3QgZmFrZVRpbWVyIG1vY2tzXG4gICAgdmFyIF9zZXRJbW1lZGlhdGUgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nICYmIHNldEltbWVkaWF0ZTtcblxuICAgIHZhciBfZGVsYXkgPSBfc2V0SW1tZWRpYXRlID8gZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgLy8gbm90IGEgZGlyZWN0IGFsaWFzIGZvciBJRTEwIGNvbXBhdGliaWxpdHlcbiAgICAgICAgX3NldEltbWVkaWF0ZShmbik7XG4gICAgfSA6IGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwcm9jZXNzLm5leHRUaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGFzeW5jLm5leHRUaWNrID0gcHJvY2Vzcy5uZXh0VGljaztcbiAgICB9IGVsc2Uge1xuICAgICAgICBhc3luYy5uZXh0VGljayA9IF9kZWxheTtcbiAgICB9XG4gICAgYXN5bmMuc2V0SW1tZWRpYXRlID0gX3NldEltbWVkaWF0ZSA/IF9kZWxheSA6IGFzeW5jLm5leHRUaWNrO1xuXG5cbiAgICBhc3luYy5mb3JFYWNoID1cbiAgICBhc3luYy5lYWNoID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBhc3luYy5lYWNoT2YoYXJyLCBfd2l0aG91dEluZGV4KGl0ZXJhdG9yKSwgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBhc3luYy5mb3JFYWNoU2VyaWVzID1cbiAgICBhc3luYy5lYWNoU2VyaWVzID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBhc3luYy5lYWNoT2ZTZXJpZXMoYXJyLCBfd2l0aG91dEluZGV4KGl0ZXJhdG9yKSwgY2FsbGJhY2spO1xuICAgIH07XG5cblxuICAgIGFzeW5jLmZvckVhY2hMaW1pdCA9XG4gICAgYXN5bmMuZWFjaExpbWl0ID0gZnVuY3Rpb24gKGFyciwgbGltaXQsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gX2VhY2hPZkxpbWl0KGxpbWl0KShhcnIsIF93aXRob3V0SW5kZXgoaXRlcmF0b3IpLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIGFzeW5jLmZvckVhY2hPZiA9XG4gICAgYXN5bmMuZWFjaE9mID0gZnVuY3Rpb24gKG9iamVjdCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gX29uY2UoY2FsbGJhY2sgfHwgbm9vcCk7XG4gICAgICAgIG9iamVjdCA9IG9iamVjdCB8fCBbXTtcblxuICAgICAgICB2YXIgaXRlciA9IF9rZXlJdGVyYXRvcihvYmplY3QpO1xuICAgICAgICB2YXIga2V5LCBjb21wbGV0ZWQgPSAwO1xuXG4gICAgICAgIHdoaWxlICgoa2V5ID0gaXRlcigpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb21wbGV0ZWQgKz0gMTtcbiAgICAgICAgICAgIGl0ZXJhdG9yKG9iamVjdFtrZXldLCBrZXksIG9ubHlfb25jZShkb25lKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29tcGxldGVkID09PSAwKSBjYWxsYmFjayhudWxsKTtcblxuICAgICAgICBmdW5jdGlvbiBkb25lKGVycikge1xuICAgICAgICAgICAgY29tcGxldGVkLS07XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIGtleSBpcyBudWxsIGluIGNhc2UgaXRlcmF0b3IgaXNuJ3QgZXhoYXVzdGVkXG4gICAgICAgICAgICAvLyBhbmQgZG9uZSByZXNvbHZlZCBzeW5jaHJvbm91c2x5LlxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBudWxsICYmIGNvbXBsZXRlZCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgYXN5bmMuZm9yRWFjaE9mU2VyaWVzID1cbiAgICBhc3luYy5lYWNoT2ZTZXJpZXMgPSBmdW5jdGlvbiAob2JqLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBfb25jZShjYWxsYmFjayB8fCBub29wKTtcbiAgICAgICAgb2JqID0gb2JqIHx8IFtdO1xuICAgICAgICB2YXIgbmV4dEtleSA9IF9rZXlJdGVyYXRvcihvYmopO1xuICAgICAgICB2YXIga2V5ID0gbmV4dEtleSgpO1xuICAgICAgICBmdW5jdGlvbiBpdGVyYXRlKCkge1xuICAgICAgICAgICAgdmFyIHN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZXJhdG9yKG9ialtrZXldLCBrZXksIG9ubHlfb25jZShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gbmV4dEtleSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3luYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZShpdGVyYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgc3luYyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGl0ZXJhdGUoKTtcbiAgICB9O1xuXG5cblxuICAgIGFzeW5jLmZvckVhY2hPZkxpbWl0ID1cbiAgICBhc3luYy5lYWNoT2ZMaW1pdCA9IGZ1bmN0aW9uIChvYmosIGxpbWl0LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgX2VhY2hPZkxpbWl0KGxpbWl0KShvYmosIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9lYWNoT2ZMaW1pdChsaW1pdCkge1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAob2JqLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gX29uY2UoY2FsbGJhY2sgfHwgbm9vcCk7XG4gICAgICAgICAgICBvYmogPSBvYmogfHwgW107XG4gICAgICAgICAgICB2YXIgbmV4dEtleSA9IF9rZXlJdGVyYXRvcihvYmopO1xuICAgICAgICAgICAgaWYgKGxpbWl0IDw9IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIHJ1bm5pbmcgPSAwO1xuICAgICAgICAgICAgdmFyIGVycm9yZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgKGZ1bmN0aW9uIHJlcGxlbmlzaCAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvbmUgJiYgcnVubmluZyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAocnVubmluZyA8IGxpbWl0ICYmICFlcnJvcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBuZXh0S2V5KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bm5pbmcgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJ1bm5pbmcgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3Iob2JqW2tleV0sIGtleSwgb25seV9vbmNlKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmcgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGVuaXNoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9O1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gZG9QYXJhbGxlbChmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4oYXN5bmMuZWFjaE9mLCBvYmosIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRvUGFyYWxsZWxMaW1pdChmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgbGltaXQsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIGZuKF9lYWNoT2ZMaW1pdChsaW1pdCksIG9iaiwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZG9TZXJpZXMoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmosIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIGZuKGFzeW5jLmVhY2hPZlNlcmllcywgb2JqLCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9hc3luY01hcChlYWNoZm4sIGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gX29uY2UoY2FsbGJhY2sgfHwgbm9vcCk7XG4gICAgICAgIGFyciA9IGFyciB8fCBbXTtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBfaXNBcnJheUxpa2UoYXJyKSA/IFtdIDoge307XG4gICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcih2YWx1ZSwgZnVuY3Rpb24gKGVyciwgdikge1xuICAgICAgICAgICAgICAgIHJlc3VsdHNbaW5kZXhdID0gdjtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0cyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jLm1hcCA9IGRvUGFyYWxsZWwoX2FzeW5jTWFwKTtcbiAgICBhc3luYy5tYXBTZXJpZXMgPSBkb1NlcmllcyhfYXN5bmNNYXApO1xuICAgIGFzeW5jLm1hcExpbWl0ID0gZG9QYXJhbGxlbExpbWl0KF9hc3luY01hcCk7XG5cbiAgICAvLyByZWR1Y2Ugb25seSBoYXMgYSBzZXJpZXMgdmVyc2lvbiwgYXMgZG9pbmcgcmVkdWNlIGluIHBhcmFsbGVsIHdvbid0XG4gICAgLy8gd29yayBpbiBtYW55IHNpdHVhdGlvbnMuXG4gICAgYXN5bmMuaW5qZWN0ID1cbiAgICBhc3luYy5mb2xkbCA9XG4gICAgYXN5bmMucmVkdWNlID0gZnVuY3Rpb24gKGFyciwgbWVtbywgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGFzeW5jLmVhY2hPZlNlcmllcyhhcnIsIGZ1bmN0aW9uICh4LCBpLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IobWVtbywgeCwgZnVuY3Rpb24gKGVyciwgdikge1xuICAgICAgICAgICAgICAgIG1lbW8gPSB2O1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBtZW1vKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGFzeW5jLmZvbGRyID1cbiAgICBhc3luYy5yZWR1Y2VSaWdodCA9IGZ1bmN0aW9uIChhcnIsIG1lbW8sIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmV2ZXJzZWQgPSBfbWFwKGFyciwgaWRlbnRpdHkpLnJldmVyc2UoKTtcbiAgICAgICAgYXN5bmMucmVkdWNlKHJldmVyc2VkLCBtZW1vLCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBhc3luYy50cmFuc2Zvcm0gPSBmdW5jdGlvbiAoYXJyLCBtZW1vLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gaXRlcmF0b3I7XG4gICAgICAgICAgICBpdGVyYXRvciA9IG1lbW87XG4gICAgICAgICAgICBtZW1vID0gX2lzQXJyYXkoYXJyKSA/IFtdIDoge307XG4gICAgICAgIH1cblxuICAgICAgICBhc3luYy5lYWNoT2YoYXJyLCBmdW5jdGlvbih2LCBrLCBjYikge1xuICAgICAgICAgICAgaXRlcmF0b3IobWVtbywgdiwgaywgY2IpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgbWVtbyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfZmlsdGVyKGVhY2hmbiwgYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGluZGV4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IoeCwgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goe2luZGV4OiBpbmRleCwgdmFsdWU6IHh9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhfbWFwKHJlc3VsdHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcbiAgICAgICAgICAgIH0pLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4LnZhbHVlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYy5zZWxlY3QgPVxuICAgIGFzeW5jLmZpbHRlciA9IGRvUGFyYWxsZWwoX2ZpbHRlcik7XG5cbiAgICBhc3luYy5zZWxlY3RMaW1pdCA9XG4gICAgYXN5bmMuZmlsdGVyTGltaXQgPSBkb1BhcmFsbGVsTGltaXQoX2ZpbHRlcik7XG5cbiAgICBhc3luYy5zZWxlY3RTZXJpZXMgPVxuICAgIGFzeW5jLmZpbHRlclNlcmllcyA9IGRvU2VyaWVzKF9maWx0ZXIpO1xuXG4gICAgZnVuY3Rpb24gX3JlamVjdChlYWNoZm4sIGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIF9maWx0ZXIoZWFjaGZuLCBhcnIsIGZ1bmN0aW9uKHZhbHVlLCBjYikge1xuICAgICAgICAgICAgaXRlcmF0b3IodmFsdWUsIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgICBjYighdik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBhc3luYy5yZWplY3QgPSBkb1BhcmFsbGVsKF9yZWplY3QpO1xuICAgIGFzeW5jLnJlamVjdExpbWl0ID0gZG9QYXJhbGxlbExpbWl0KF9yZWplY3QpO1xuICAgIGFzeW5jLnJlamVjdFNlcmllcyA9IGRvU2VyaWVzKF9yZWplY3QpO1xuXG4gICAgZnVuY3Rpb24gX2NyZWF0ZVRlc3RlcihlYWNoZm4sIGNoZWNrLCBnZXRSZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGFyciwgbGltaXQsIGl0ZXJhdG9yLCBjYikge1xuICAgICAgICAgICAgZnVuY3Rpb24gZG9uZSgpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2IpIGNiKGdldFJlc3VsdChmYWxzZSwgdm9pZCAwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBpdGVyYXRlZSh4LCBfLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmICghY2IpIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yKHgsIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYiAmJiBjaGVjayh2KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2IoZ2V0UmVzdWx0KHRydWUsIHgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiID0gaXRlcmF0b3IgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAzKSB7XG4gICAgICAgICAgICAgICAgZWFjaGZuKGFyciwgbGltaXQsIGl0ZXJhdGVlLCBkb25lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2IgPSBpdGVyYXRvcjtcbiAgICAgICAgICAgICAgICBpdGVyYXRvciA9IGxpbWl0O1xuICAgICAgICAgICAgICAgIGVhY2hmbihhcnIsIGl0ZXJhdGVlLCBkb25lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYy5hbnkgPVxuICAgIGFzeW5jLnNvbWUgPSBfY3JlYXRlVGVzdGVyKGFzeW5jLmVhY2hPZiwgdG9Cb29sLCBpZGVudGl0eSk7XG5cbiAgICBhc3luYy5zb21lTGltaXQgPSBfY3JlYXRlVGVzdGVyKGFzeW5jLmVhY2hPZkxpbWl0LCB0b0Jvb2wsIGlkZW50aXR5KTtcblxuICAgIGFzeW5jLmFsbCA9XG4gICAgYXN5bmMuZXZlcnkgPSBfY3JlYXRlVGVzdGVyKGFzeW5jLmVhY2hPZiwgbm90SWQsIG5vdElkKTtcblxuICAgIGFzeW5jLmV2ZXJ5TGltaXQgPSBfY3JlYXRlVGVzdGVyKGFzeW5jLmVhY2hPZkxpbWl0LCBub3RJZCwgbm90SWQpO1xuXG4gICAgZnVuY3Rpb24gX2ZpbmRHZXRSZXN1bHQodiwgeCkge1xuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgYXN5bmMuZGV0ZWN0ID0gX2NyZWF0ZVRlc3Rlcihhc3luYy5lYWNoT2YsIGlkZW50aXR5LCBfZmluZEdldFJlc3VsdCk7XG4gICAgYXN5bmMuZGV0ZWN0U2VyaWVzID0gX2NyZWF0ZVRlc3Rlcihhc3luYy5lYWNoT2ZTZXJpZXMsIGlkZW50aXR5LCBfZmluZEdldFJlc3VsdCk7XG4gICAgYXN5bmMuZGV0ZWN0TGltaXQgPSBfY3JlYXRlVGVzdGVyKGFzeW5jLmVhY2hPZkxpbWl0LCBpZGVudGl0eSwgX2ZpbmRHZXRSZXN1bHQpO1xuXG4gICAgYXN5bmMuc29ydEJ5ID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGFzeW5jLm1hcChhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IoeCwgZnVuY3Rpb24gKGVyciwgY3JpdGVyaWEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCB7dmFsdWU6IHgsIGNyaXRlcmlhOiBjcml0ZXJpYX0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyLCByZXN1bHRzKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBfbWFwKHJlc3VsdHMuc29ydChjb21wYXJhdG9yKSwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgudmFsdWU7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZ1bmN0aW9uIGNvbXBhcmF0b3IobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYSwgYiA9IHJpZ2h0LmNyaXRlcmlhO1xuICAgICAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGFzeW5jLmF1dG8gPSBmdW5jdGlvbiAodGFza3MsIGNvbmN1cnJlbmN5LCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gY29uY3VycmVuY3kgaXMgb3B0aW9uYWwsIHNoaWZ0IHRoZSBhcmdzLlxuICAgICAgICAgICAgY2FsbGJhY2sgPSBjb25jdXJyZW5jeTtcbiAgICAgICAgICAgIGNvbmN1cnJlbmN5ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayA9IF9vbmNlKGNhbGxiYWNrIHx8IG5vb3ApO1xuICAgICAgICB2YXIga2V5cyA9IF9rZXlzKHRhc2tzKTtcbiAgICAgICAgdmFyIHJlbWFpbmluZ1Rhc2tzID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIGlmICghcmVtYWluaW5nVGFza3MpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbmN1cnJlbmN5KSB7XG4gICAgICAgICAgICBjb25jdXJyZW5jeSA9IHJlbWFpbmluZ1Rhc2tzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgdmFyIHJ1bm5pbmdUYXNrcyA9IDA7XG5cbiAgICAgICAgdmFyIGhhc0Vycm9yID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IFtdO1xuICAgICAgICBmdW5jdGlvbiBhZGRMaXN0ZW5lcihmbikge1xuICAgICAgICAgICAgbGlzdGVuZXJzLnVuc2hpZnQoZm4pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGZuKSB7XG4gICAgICAgICAgICB2YXIgaWR4ID0gX2luZGV4T2YobGlzdGVuZXJzLCBmbik7XG4gICAgICAgICAgICBpZiAoaWR4ID49IDApIGxpc3RlbmVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB0YXNrQ29tcGxldGUoKSB7XG4gICAgICAgICAgICByZW1haW5pbmdUYXNrcy0tO1xuICAgICAgICAgICAgX2FycmF5RWFjaChsaXN0ZW5lcnMuc2xpY2UoMCksIGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFkZExpc3RlbmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghcmVtYWluaW5nVGFza3MpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgX2FycmF5RWFjaChrZXlzLCBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgaWYgKGhhc0Vycm9yKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgdGFzayA9IF9pc0FycmF5KHRhc2tzW2tdKSA/IHRhc2tzW2tdOiBbdGFza3Nba11dO1xuICAgICAgICAgICAgdmFyIHRhc2tDYWxsYmFjayA9IF9yZXN0UGFyYW0oZnVuY3Rpb24oZXJyLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgcnVubmluZ1Rhc2tzLS07XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNhZmVSZXN1bHRzID0ge307XG4gICAgICAgICAgICAgICAgICAgIF9mb3JFYWNoT2YocmVzdWx0cywgZnVuY3Rpb24odmFsLCBya2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzYWZlUmVzdWx0c1tya2V5XSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNhZmVSZXN1bHRzW2tdID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgaGFzRXJyb3IgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgc2FmZVJlc3VsdHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1trXSA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZSh0YXNrQ29tcGxldGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHJlcXVpcmVzID0gdGFzay5zbGljZSgwLCB0YXNrLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgLy8gcHJldmVudCBkZWFkLWxvY2tzXG4gICAgICAgICAgICB2YXIgbGVuID0gcmVxdWlyZXMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGRlcDtcbiAgICAgICAgICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgICAgICAgICAgIGlmICghKGRlcCA9IHRhc2tzW3JlcXVpcmVzW2xlbl1dKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhcyBub25leGlzdGVudCBkZXBlbmRlbmN5IGluICcgKyByZXF1aXJlcy5qb2luKCcsICcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF9pc0FycmF5KGRlcCkgJiYgX2luZGV4T2YoZGVwLCBrKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzIGN5Y2xpYyBkZXBlbmRlbmNpZXMnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiByZWFkeSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcnVubmluZ1Rhc2tzIDwgY29uY3VycmVuY3kgJiYgX3JlZHVjZShyZXF1aXJlcywgZnVuY3Rpb24gKGEsIHgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChhICYmIHJlc3VsdHMuaGFzT3duUHJvcGVydHkoeCkpO1xuICAgICAgICAgICAgICAgIH0sIHRydWUpICYmICFyZXN1bHRzLmhhc093blByb3BlcnR5KGspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlYWR5KCkpIHtcbiAgICAgICAgICAgICAgICBydW5uaW5nVGFza3MrKztcbiAgICAgICAgICAgICAgICB0YXNrW3Rhc2subGVuZ3RoIC0gMV0odGFza0NhbGxiYWNrLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGxpc3RlbmVyKCkge1xuICAgICAgICAgICAgICAgIGlmIChyZWFkeSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bm5pbmdUYXNrcysrO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIHRhc2tbdGFzay5sZW5ndGggLSAxXSh0YXNrQ2FsbGJhY2ssIHJlc3VsdHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuXG5cbiAgICBhc3luYy5yZXRyeSA9IGZ1bmN0aW9uKHRpbWVzLCB0YXNrLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgREVGQVVMVF9USU1FUyA9IDU7XG4gICAgICAgIHZhciBERUZBVUxUX0lOVEVSVkFMID0gMDtcblxuICAgICAgICB2YXIgYXR0ZW1wdHMgPSBbXTtcblxuICAgICAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgICAgIHRpbWVzOiBERUZBVUxUX1RJTUVTLFxuICAgICAgICAgICAgaW50ZXJ2YWw6IERFRkFVTFRfSU5URVJWQUxcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBwYXJzZVRpbWVzKGFjYywgdCl7XG4gICAgICAgICAgICBpZih0eXBlb2YgdCA9PT0gJ251bWJlcicpe1xuICAgICAgICAgICAgICAgIGFjYy50aW1lcyA9IHBhcnNlSW50KHQsIDEwKSB8fCBERUZBVUxUX1RJTUVTO1xuICAgICAgICAgICAgfSBlbHNlIGlmKHR5cGVvZiB0ID09PSAnb2JqZWN0Jyl7XG4gICAgICAgICAgICAgICAgYWNjLnRpbWVzID0gcGFyc2VJbnQodC50aW1lcywgMTApIHx8IERFRkFVTFRfVElNRVM7XG4gICAgICAgICAgICAgICAgYWNjLmludGVydmFsID0gcGFyc2VJbnQodC5pbnRlcnZhbCwgMTApIHx8IERFRkFVTFRfSU5URVJWQUw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgYXJndW1lbnQgdHlwZSBmb3IgXFwndGltZXNcXCc6ICcgKyB0eXBlb2YgdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCA8IDEgfHwgbGVuZ3RoID4gMykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cyAtIG11c3QgYmUgZWl0aGVyICh0YXNrKSwgKHRhc2ssIGNhbGxiYWNrKSwgKHRpbWVzLCB0YXNrKSBvciAodGltZXMsIHRhc2ssIGNhbGxiYWNrKScpO1xuICAgICAgICB9IGVsc2UgaWYgKGxlbmd0aCA8PSAyICYmIHR5cGVvZiB0aW1lcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSB0YXNrO1xuICAgICAgICAgICAgdGFzayA9IHRpbWVzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGltZXMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHBhcnNlVGltZXMob3B0cywgdGltZXMpO1xuICAgICAgICB9XG4gICAgICAgIG9wdHMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgb3B0cy50YXNrID0gdGFzaztcblxuICAgICAgICBmdW5jdGlvbiB3cmFwcGVkVGFzayh3cmFwcGVkQ2FsbGJhY2ssIHdyYXBwZWRSZXN1bHRzKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiByZXRyeUF0dGVtcHQodGFzaywgZmluYWxBdHRlbXB0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHNlcmllc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2soZnVuY3Rpb24oZXJyLCByZXN1bHQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzQ2FsbGJhY2soIWVyciB8fCBmaW5hbEF0dGVtcHQsIHtlcnI6IGVyciwgcmVzdWx0OiByZXN1bHR9KTtcbiAgICAgICAgICAgICAgICAgICAgfSwgd3JhcHBlZFJlc3VsdHMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHJldHJ5SW50ZXJ2YWwoaW50ZXJ2YWwpe1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihzZXJpZXNDYWxsYmFjayl7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0NhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9LCBpbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2hpbGUgKG9wdHMudGltZXMpIHtcblxuICAgICAgICAgICAgICAgIHZhciBmaW5hbEF0dGVtcHQgPSAhKG9wdHMudGltZXMtPTEpO1xuICAgICAgICAgICAgICAgIGF0dGVtcHRzLnB1c2gocmV0cnlBdHRlbXB0KG9wdHMudGFzaywgZmluYWxBdHRlbXB0KSk7XG4gICAgICAgICAgICAgICAgaWYoIWZpbmFsQXR0ZW1wdCAmJiBvcHRzLmludGVydmFsID4gMCl7XG4gICAgICAgICAgICAgICAgICAgIGF0dGVtcHRzLnB1c2gocmV0cnlJbnRlcnZhbChvcHRzLmludGVydmFsKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhc3luYy5zZXJpZXMoYXR0ZW1wdHMsIGZ1bmN0aW9uKGRvbmUsIGRhdGEpe1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgKHdyYXBwZWRDYWxsYmFjayB8fCBvcHRzLmNhbGxiYWNrKShkYXRhLmVyciwgZGF0YS5yZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBhIGNhbGxiYWNrIGlzIHBhc3NlZCwgcnVuIHRoaXMgYXMgYSBjb250cm9sbCBmbG93XG4gICAgICAgIHJldHVybiBvcHRzLmNhbGxiYWNrID8gd3JhcHBlZFRhc2soKSA6IHdyYXBwZWRUYXNrO1xuICAgIH07XG5cbiAgICBhc3luYy53YXRlcmZhbGwgPSBmdW5jdGlvbiAodGFza3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gX29uY2UoY2FsbGJhY2sgfHwgbm9vcCk7XG4gICAgICAgIGlmICghX2lzQXJyYXkodGFza3MpKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCB0byB3YXRlcmZhbGwgbXVzdCBiZSBhbiBhcnJheSBvZiBmdW5jdGlvbnMnKTtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGFza3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB3cmFwSXRlcmF0b3IoaXRlcmF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVzdFBhcmFtKGZ1bmN0aW9uIChlcnIsIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIFtlcnJdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaCh3cmFwSXRlcmF0b3IobmV4dCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbnN1cmVBc3luYyhpdGVyYXRvcikuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgd3JhcEl0ZXJhdG9yKGFzeW5jLml0ZXJhdG9yKHRhc2tzKSkoKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gX3BhcmFsbGVsKGVhY2hmbiwgdGFza3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBfaXNBcnJheUxpa2UodGFza3MpID8gW10gOiB7fTtcblxuICAgICAgICBlYWNoZm4odGFza3MsIGZ1bmN0aW9uICh0YXNrLCBrZXksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0YXNrKF9yZXN0UGFyYW0oZnVuY3Rpb24gKGVyciwgYXJncykge1xuICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRzW2tleV0gPSBhcmdzO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0cyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jLnBhcmFsbGVsID0gZnVuY3Rpb24gKHRhc2tzLCBjYWxsYmFjaykge1xuICAgICAgICBfcGFyYWxsZWwoYXN5bmMuZWFjaE9mLCB0YXNrcywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBhc3luYy5wYXJhbGxlbExpbWl0ID0gZnVuY3Rpb24odGFza3MsIGxpbWl0LCBjYWxsYmFjaykge1xuICAgICAgICBfcGFyYWxsZWwoX2VhY2hPZkxpbWl0KGxpbWl0KSwgdGFza3MsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMuc2VyaWVzID0gZnVuY3Rpb24odGFza3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIF9wYXJhbGxlbChhc3luYy5lYWNoT2ZTZXJpZXMsIHRhc2tzLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIGFzeW5jLml0ZXJhdG9yID0gZnVuY3Rpb24gKHRhc2tzKSB7XG4gICAgICAgIGZ1bmN0aW9uIG1ha2VDYWxsYmFjayhpbmRleCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gZm4oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhc2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0YXNrc1tpbmRleF0uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZuLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChpbmRleCA8IHRhc2tzLmxlbmd0aCAtIDEpID8gbWFrZUNhbGxiYWNrKGluZGV4ICsgMSk6IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYWtlQ2FsbGJhY2soMCk7XG4gICAgfTtcblxuICAgIGFzeW5jLmFwcGx5ID0gX3Jlc3RQYXJhbShmdW5jdGlvbiAoZm4sIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIF9yZXN0UGFyYW0oZnVuY3Rpb24gKGNhbGxBcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkoXG4gICAgICAgICAgICAgICAgbnVsbCwgYXJncy5jb25jYXQoY2FsbEFyZ3MpXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIF9jb25jYXQoZWFjaGZuLCBhcnIsIGZuLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBpbmRleCwgY2IpIHtcbiAgICAgICAgICAgIGZuKHgsIGZ1bmN0aW9uIChlcnIsIHkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHkgfHwgW10pO1xuICAgICAgICAgICAgICAgIGNiKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMuY29uY2F0ID0gZG9QYXJhbGxlbChfY29uY2F0KTtcbiAgICBhc3luYy5jb25jYXRTZXJpZXMgPSBkb1NlcmllcyhfY29uY2F0KTtcblxuICAgIGFzeW5jLndoaWxzdCA9IGZ1bmN0aW9uICh0ZXN0LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wO1xuICAgICAgICBpZiAodGVzdCgpKSB7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IF9yZXN0UGFyYW0oZnVuY3Rpb24oZXJyLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGVzdC5hcHBseSh0aGlzLCBhcmdzKSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvcihuZXh0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBbbnVsbF0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGl0ZXJhdG9yKG5leHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgYXN5bmMuZG9XaGlsc3QgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIHRlc3QsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBjYWxscyA9IDA7XG4gICAgICAgIHJldHVybiBhc3luYy53aGlsc3QoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gKytjYWxscyA8PSAxIHx8IHRlc3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMudW50aWwgPSBmdW5jdGlvbiAodGVzdCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBhc3luYy53aGlsc3QoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gIXRlc3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMuZG9VbnRpbCA9IGZ1bmN0aW9uIChpdGVyYXRvciwgdGVzdCwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGFzeW5jLmRvV2hpbHN0KGl0ZXJhdG9yLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAhdGVzdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIGFzeW5jLmR1cmluZyA9IGZ1bmN0aW9uICh0ZXN0LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wO1xuXG4gICAgICAgIHZhciBuZXh0ID0gX3Jlc3RQYXJhbShmdW5jdGlvbihlcnIsIGFyZ3MpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2goY2hlY2spO1xuICAgICAgICAgICAgICAgIHRlc3QuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBjaGVjayA9IGZ1bmN0aW9uKGVyciwgdHJ1dGgpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0cnV0aCkge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yKG5leHQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0ZXN0KGNoZWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMuZG9EdXJpbmcgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIHRlc3QsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBjYWxscyA9IDA7XG4gICAgICAgIGFzeW5jLmR1cmluZyhmdW5jdGlvbihuZXh0KSB7XG4gICAgICAgICAgICBpZiAoY2FsbHMrKyA8IDEpIHtcbiAgICAgICAgICAgICAgICBuZXh0KG51bGwsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZXN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9xdWV1ZSh3b3JrZXIsIGNvbmN1cnJlbmN5LCBwYXlsb2FkKSB7XG4gICAgICAgIGlmIChjb25jdXJyZW5jeSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25jdXJyZW5jeSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihjb25jdXJyZW5jeSA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25jdXJyZW5jeSBtdXN0IG5vdCBiZSB6ZXJvJyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gX2luc2VydChxLCBkYXRhLCBwb3MsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCAmJiB0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRhc2sgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcS5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghX2lzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gW2RhdGFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoZGF0YS5sZW5ndGggPT09IDAgJiYgcS5pZGxlKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBjYWxsIGRyYWluIGltbWVkaWF0ZWx5IGlmIHRoZXJlIGFyZSBubyB0YXNrc1xuICAgICAgICAgICAgICAgIHJldHVybiBhc3luYy5zZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHEuZHJhaW4oKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9hcnJheUVhY2goZGF0YSwgZnVuY3Rpb24odGFzaykge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiB0YXNrLFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2sgfHwgbm9vcFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAocG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIHEudGFza3MudW5zaGlmdChpdGVtKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBxLnRhc2tzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHEudGFza3MubGVuZ3RoID09PSBxLmNvbmN1cnJlbmN5KSB7XG4gICAgICAgICAgICAgICAgICAgIHEuc2F0dXJhdGVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUocS5wcm9jZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBfbmV4dChxLCB0YXNrcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgd29ya2VycyAtPSAxO1xuXG4gICAgICAgICAgICAgICAgdmFyIHJlbW92ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICBfYXJyYXlFYWNoKHRhc2tzLCBmdW5jdGlvbiAodGFzaykge1xuICAgICAgICAgICAgICAgICAgICBfYXJyYXlFYWNoKHdvcmtlcnNMaXN0LCBmdW5jdGlvbiAod29ya2VyLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdvcmtlciA9PT0gdGFzayAmJiAhcmVtb3ZlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtlcnNMaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHRhc2suY2FsbGJhY2suYXBwbHkodGFzaywgYXJncyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHEudGFza3MubGVuZ3RoICsgd29ya2VycyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBxLmRyYWluKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHEucHJvY2VzcygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3b3JrZXJzID0gMDtcbiAgICAgICAgdmFyIHdvcmtlcnNMaXN0ID0gW107XG4gICAgICAgIHZhciBxID0ge1xuICAgICAgICAgICAgdGFza3M6IFtdLFxuICAgICAgICAgICAgY29uY3VycmVuY3k6IGNvbmN1cnJlbmN5LFxuICAgICAgICAgICAgcGF5bG9hZDogcGF5bG9hZCxcbiAgICAgICAgICAgIHNhdHVyYXRlZDogbm9vcCxcbiAgICAgICAgICAgIGVtcHR5OiBub29wLFxuICAgICAgICAgICAgZHJhaW46IG5vb3AsXG4gICAgICAgICAgICBzdGFydGVkOiBmYWxzZSxcbiAgICAgICAgICAgIHBhdXNlZDogZmFsc2UsXG4gICAgICAgICAgICBwdXNoOiBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBfaW5zZXJ0KHEsIGRhdGEsIGZhbHNlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAga2lsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHEuZHJhaW4gPSBub29wO1xuICAgICAgICAgICAgICAgIHEudGFza3MgPSBbXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bnNoaWZ0OiBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBfaW5zZXJ0KHEsIGRhdGEsIHRydWUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcm9jZXNzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUoIXEucGF1c2VkICYmIHdvcmtlcnMgPCBxLmNvbmN1cnJlbmN5ICYmIHEudGFza3MubGVuZ3RoKXtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgdGFza3MgPSBxLnBheWxvYWQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgcS50YXNrcy5zcGxpY2UoMCwgcS5wYXlsb2FkKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBxLnRhc2tzLnNwbGljZSgwLCBxLnRhc2tzLmxlbmd0aCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBfbWFwKHRhc2tzLCBmdW5jdGlvbiAodGFzaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhc2suZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHEudGFza3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxLmVtcHR5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd29ya2VycyArPSAxO1xuICAgICAgICAgICAgICAgICAgICB3b3JrZXJzTGlzdC5wdXNoKHRhc2tzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNiID0gb25seV9vbmNlKF9uZXh0KHEsIHRhc2tzKSk7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtlcihkYXRhLCBjYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxlbmd0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBxLnRhc2tzLmxlbmd0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBydW5uaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdvcmtlcnM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd29ya2Vyc0xpc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd29ya2Vyc0xpc3Q7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaWRsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHEudGFza3MubGVuZ3RoICsgd29ya2VycyA9PT0gMDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXVzZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHEucGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXN1bWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAocS5wYXVzZWQgPT09IGZhbHNlKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgICAgIHEucGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VtZUNvdW50ID0gTWF0aC5taW4ocS5jb25jdXJyZW5jeSwgcS50YXNrcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gY2FsbCBxLnByb2Nlc3Mgb25jZSBwZXIgY29uY3VycmVudFxuICAgICAgICAgICAgICAgIC8vIHdvcmtlciB0byBwcmVzZXJ2ZSBmdWxsIGNvbmN1cnJlbmN5IGFmdGVyIHBhdXNlXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgdyA9IDE7IHcgPD0gcmVzdW1lQ291bnQ7IHcrKykge1xuICAgICAgICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUocS5wcm9jZXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBxO1xuICAgIH1cblxuICAgIGFzeW5jLnF1ZXVlID0gZnVuY3Rpb24gKHdvcmtlciwgY29uY3VycmVuY3kpIHtcbiAgICAgICAgdmFyIHEgPSBfcXVldWUoZnVuY3Rpb24gKGl0ZW1zLCBjYikge1xuICAgICAgICAgICAgd29ya2VyKGl0ZW1zWzBdLCBjYik7XG4gICAgICAgIH0sIGNvbmN1cnJlbmN5LCAxKTtcblxuICAgICAgICByZXR1cm4gcTtcbiAgICB9O1xuXG4gICAgYXN5bmMucHJpb3JpdHlRdWV1ZSA9IGZ1bmN0aW9uICh3b3JrZXIsIGNvbmN1cnJlbmN5KSB7XG5cbiAgICAgICAgZnVuY3Rpb24gX2NvbXBhcmVUYXNrcyhhLCBiKXtcbiAgICAgICAgICAgIHJldHVybiBhLnByaW9yaXR5IC0gYi5wcmlvcml0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIF9iaW5hcnlTZWFyY2goc2VxdWVuY2UsIGl0ZW0sIGNvbXBhcmUpIHtcbiAgICAgICAgICAgIHZhciBiZWcgPSAtMSxcbiAgICAgICAgICAgICAgICBlbmQgPSBzZXF1ZW5jZS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgd2hpbGUgKGJlZyA8IGVuZCkge1xuICAgICAgICAgICAgICAgIHZhciBtaWQgPSBiZWcgKyAoKGVuZCAtIGJlZyArIDEpID4+PiAxKTtcbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyZShpdGVtLCBzZXF1ZW5jZVttaWRdKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlZyA9IG1pZDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbmQgPSBtaWQgLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiZWc7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBfaW5zZXJ0KHEsIGRhdGEsIHByaW9yaXR5LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrICE9IG51bGwgJiYgdHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0YXNrIGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHEuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIV9pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IFtkYXRhXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gY2FsbCBkcmFpbiBpbW1lZGlhdGVseSBpZiB0aGVyZSBhcmUgbm8gdGFza3NcbiAgICAgICAgICAgICAgICByZXR1cm4gYXN5bmMuc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBxLmRyYWluKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfYXJyYXlFYWNoKGRhdGEsIGZ1bmN0aW9uKHRhc2spIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdGFzayxcbiAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHk6IHByaW9yaXR5LFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nID8gY2FsbGJhY2sgOiBub29wXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHEudGFza3Muc3BsaWNlKF9iaW5hcnlTZWFyY2gocS50YXNrcywgaXRlbSwgX2NvbXBhcmVUYXNrcykgKyAxLCAwLCBpdGVtKTtcblxuICAgICAgICAgICAgICAgIGlmIChxLnRhc2tzLmxlbmd0aCA9PT0gcS5jb25jdXJyZW5jeSkge1xuICAgICAgICAgICAgICAgICAgICBxLnNhdHVyYXRlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUocS5wcm9jZXNzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RhcnQgd2l0aCBhIG5vcm1hbCBxdWV1ZVxuICAgICAgICB2YXIgcSA9IGFzeW5jLnF1ZXVlKHdvcmtlciwgY29uY3VycmVuY3kpO1xuXG4gICAgICAgIC8vIE92ZXJyaWRlIHB1c2ggdG8gYWNjZXB0IHNlY29uZCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIHByaW9yaXR5XG4gICAgICAgIHEucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBwcmlvcml0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIF9pbnNlcnQocSwgZGF0YSwgcHJpb3JpdHksIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBSZW1vdmUgdW5zaGlmdCBmdW5jdGlvblxuICAgICAgICBkZWxldGUgcS51bnNoaWZ0O1xuXG4gICAgICAgIHJldHVybiBxO1xuICAgIH07XG5cbiAgICBhc3luYy5jYXJnbyA9IGZ1bmN0aW9uICh3b3JrZXIsIHBheWxvYWQpIHtcbiAgICAgICAgcmV0dXJuIF9xdWV1ZSh3b3JrZXIsIDEsIHBheWxvYWQpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfY29uc29sZV9mbihuYW1lKSB7XG4gICAgICAgIHJldHVybiBfcmVzdFBhcmFtKGZ1bmN0aW9uIChmbiwgYXJncykge1xuICAgICAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncy5jb25jYXQoW19yZXN0UGFyYW0oZnVuY3Rpb24gKGVyciwgYXJncykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29uc29sZVtuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2FycmF5RWFjaChhcmdzLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGVbbmFtZV0oeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMubG9nID0gX2NvbnNvbGVfZm4oJ2xvZycpO1xuICAgIGFzeW5jLmRpciA9IF9jb25zb2xlX2ZuKCdkaXInKTtcbiAgICAvKmFzeW5jLmluZm8gPSBfY29uc29sZV9mbignaW5mbycpO1xuICAgIGFzeW5jLndhcm4gPSBfY29uc29sZV9mbignd2FybicpO1xuICAgIGFzeW5jLmVycm9yID0gX2NvbnNvbGVfZm4oJ2Vycm9yJyk7Ki9cblxuICAgIGFzeW5jLm1lbW9pemUgPSBmdW5jdGlvbiAoZm4sIGhhc2hlcikge1xuICAgICAgICB2YXIgbWVtbyA9IHt9O1xuICAgICAgICB2YXIgcXVldWVzID0ge307XG4gICAgICAgIHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICAgICAgICBoYXNoZXIgPSBoYXNoZXIgfHwgaWRlbnRpdHk7XG4gICAgICAgIHZhciBtZW1vaXplZCA9IF9yZXN0UGFyYW0oZnVuY3Rpb24gbWVtb2l6ZWQoYXJncykge1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICAgICAgICAgIHZhciBrZXkgPSBoYXNoZXIuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICBpZiAoaGFzLmNhbGwobWVtbywga2V5KSkgeyAgIFxuICAgICAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIG1lbW9ba2V5XSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoYXMuY2FsbChxdWV1ZXMsIGtleSkpIHtcbiAgICAgICAgICAgICAgICBxdWV1ZXNba2V5XS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHF1ZXVlc1trZXldID0gW2NhbGxiYWNrXTtcbiAgICAgICAgICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzLmNvbmNhdChbX3Jlc3RQYXJhbShmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgICAgICAgICBtZW1vW2tleV0gPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcSA9IHF1ZXVlc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcXVldWVzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHFbaV0uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG1lbW9pemVkLm1lbW8gPSBtZW1vO1xuICAgICAgICBtZW1vaXplZC51bm1lbW9pemVkID0gZm47XG4gICAgICAgIHJldHVybiBtZW1vaXplZDtcbiAgICB9O1xuXG4gICAgYXN5bmMudW5tZW1vaXplID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKGZuLnVubWVtb2l6ZWQgfHwgZm4pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF90aW1lcyhtYXBwZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjb3VudCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBtYXBwZXIoX3JhbmdlKGNvdW50KSwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYy50aW1lcyA9IF90aW1lcyhhc3luYy5tYXApO1xuICAgIGFzeW5jLnRpbWVzU2VyaWVzID0gX3RpbWVzKGFzeW5jLm1hcFNlcmllcyk7XG4gICAgYXN5bmMudGltZXNMaW1pdCA9IGZ1bmN0aW9uIChjb3VudCwgbGltaXQsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gYXN5bmMubWFwTGltaXQoX3JhbmdlKGNvdW50KSwgbGltaXQsIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIGFzeW5jLnNlcSA9IGZ1bmN0aW9uICgvKiBmdW5jdGlvbnMuLi4gKi8pIHtcbiAgICAgICAgdmFyIGZucyA9IGFyZ3VtZW50cztcbiAgICAgICAgcmV0dXJuIF9yZXN0UGFyYW0oZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgYXJncy5wb3AoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBub29wO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhc3luYy5yZWR1Y2UoZm5zLCBhcmdzLCBmdW5jdGlvbiAobmV3YXJncywgZm4sIGNiKSB7XG4gICAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgbmV3YXJncy5jb25jYXQoW19yZXN0UGFyYW0oZnVuY3Rpb24gKGVyciwgbmV4dGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY2IoZXJyLCBuZXh0YXJncyk7XG4gICAgICAgICAgICAgICAgfSldKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKGVyciwgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHRoYXQsIFtlcnJdLmNvbmNhdChyZXN1bHRzKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGFzeW5jLmNvbXBvc2UgPSBmdW5jdGlvbiAoLyogZnVuY3Rpb25zLi4uICovKSB7XG4gICAgICAgIHJldHVybiBhc3luYy5zZXEuYXBwbHkobnVsbCwgQXJyYXkucHJvdG90eXBlLnJldmVyc2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9O1xuXG5cbiAgICBmdW5jdGlvbiBfYXBwbHlFYWNoKGVhY2hmbikge1xuICAgICAgICByZXR1cm4gX3Jlc3RQYXJhbShmdW5jdGlvbihmbnMsIGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBnbyA9IF9yZXN0UGFyYW0oZnVuY3Rpb24oYXJncykge1xuICAgICAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBlYWNoZm4oZm5zLCBmdW5jdGlvbiAoZm4sIF8sIGNiKSB7XG4gICAgICAgICAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIGFyZ3MuY29uY2F0KFtjYl0pKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdvLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYy5hcHBseUVhY2ggPSBfYXBwbHlFYWNoKGFzeW5jLmVhY2hPZik7XG4gICAgYXN5bmMuYXBwbHlFYWNoU2VyaWVzID0gX2FwcGx5RWFjaChhc3luYy5lYWNoT2ZTZXJpZXMpO1xuXG5cbiAgICBhc3luYy5mb3JldmVyID0gZnVuY3Rpb24gKGZuLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZG9uZSA9IG9ubHlfb25jZShjYWxsYmFjayB8fCBub29wKTtcbiAgICAgICAgdmFyIHRhc2sgPSBlbnN1cmVBc3luYyhmbik7XG4gICAgICAgIGZ1bmN0aW9uIG5leHQoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbmUoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhc2sobmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCgpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBlbnN1cmVBc3luYyhmbikge1xuICAgICAgICByZXR1cm4gX3Jlc3RQYXJhbShmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICAgICAgICAgIGFyZ3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlubmVyQXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICBpZiAoc3luYykge1xuICAgICAgICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgaW5uZXJBcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgaW5uZXJBcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBzeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgc3luYyA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYy5lbnN1cmVBc3luYyA9IGVuc3VyZUFzeW5jO1xuXG4gICAgYXN5bmMuY29uc3RhbnQgPSBfcmVzdFBhcmFtKGZ1bmN0aW9uKHZhbHVlcykge1xuICAgICAgICB2YXIgYXJncyA9IFtudWxsXS5jb25jYXQodmFsdWVzKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgYXN5bmMud3JhcFN5bmMgPVxuICAgIGFzeW5jLmFzeW5jaWZ5ID0gZnVuY3Rpb24gYXN5bmNpZnkoZnVuYykge1xuICAgICAgICByZXR1cm4gX3Jlc3RQYXJhbShmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgcmVzdWx0IGlzIFByb21pc2Ugb2JqZWN0XG4gICAgICAgICAgICBpZiAoX2lzT2JqZWN0KHJlc3VsdCkgJiYgdHlwZW9mIHJlc3VsdC50aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLm1lc3NhZ2UgPyBlcnIgOiBuZXcgRXJyb3IoZXJyKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBOb2RlLmpzXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gYXN5bmM7XG4gICAgfVxuICAgIC8vIEFNRCAvIFJlcXVpcmVKU1xuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoW10sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBhc3luYztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGluY2x1ZGVkIGRpcmVjdGx5IHZpYSA8c2NyaXB0PiB0YWdcbiAgICBlbHNlIHtcbiAgICAgICAgcm9vdC5hc3luYyA9IGFzeW5jO1xuICAgIH1cblxufSgpKTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG4vLyBUT0RPKHNodHlsbWFuKVxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIl19\n"],"file":"async-chainable.js","sourceRoot":"/source/"}